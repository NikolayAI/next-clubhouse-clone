function e(e){return e&&'object'==typeof e&&'default'in e?e.default:e}function t(e,t,r){let n=[effector.step.run({fn:e=>t(e)})];if(r){let t=effector.createNode({node:n}),o=e.graphite.id,u=r.additionalLinks,s=u[o]||[];return u[o]=s,s.push(t),()=>{let e=s.indexOf(t);-1!==e&&s.splice(e,1),effector.clearNode(t)}}{let t=effector.createNode({node:n,parent:[e],family:{owners:e}});return()=>{effector.clearNode(t)}}}function r(e,t){return t.displayName=e,t}function n(e,r){effector.is.store(e)||d('expect useStore argument to be a store');let n=y(e,r),o=v(),u=p.useRef({store:e,value:n,pending:0});return f((()=>{let n=t(e,(e=>{let t=u.current;t.pending||(t.value=e,t.pending=1,o(),t.pending=0)}),r),s=y(e,r),a=u.current;return a.store===e&&a.value!==s&&(a.value=s,a.pending=1,o(),a.pending=0),a.store=e,n}),[e,r]),n}function o([e,r],n){let o,s,a,l=m;r?(o=r,s=e,a=[]):(o=e.fn,s=e.store,a=e.keys,l=e.updateFilter||m),effector.is.store(s)||d('useStoreMap expects a store'),Array.isArray(a)||d('useStoreMap expects an array as keys'),'function'!=typeof o&&d('useStoreMap expects a function');let c=p.useRef({}),i=c.current;i.fn=o,i.upd=l,i.init=i.store===s,i.store=s;let x=v(),k=[n,...a],g=p.useMemo((()=>(u(y(s,n),a,c.current),t(s,(e=>u(e,a,c.current,x)),n))),k);return f((()=>()=>g()),k),i.val}function u(e,t,r,n){let o=r.fn(e,t);r.init?void 0!==o&&m(o,r.val)&&r.upd(o,r.val)&&(r.val=o,n&&n()):(r.val=o,r.init=1)}function s(){let e=p.useContext(k);return e||d('No scope found, consider adding <Provider> to app root'),e}function a(e,t={}){let[r,n,o]=c([e.open,e.close,e.set]);((e,t={})=>{let r=p.useRef({value:null,count:0});f((()=>(e.open(r.current.value),()=>e.close(r.current.value))),[e]),((e,t)=>{if(e===t)return 1;if('object'==typeof e&&null!==e&&'object'==typeof t&&null!==t){let r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return 0;for(let n=0;n<r.length;n++){let o=r[n];if(e[o]!==t[o])return 0}return 1}return 0})(r.current.value,t)||(r.current.value=t,r.current.count+=1),f((()=>{e.set(r.current.value)}),[r.current.count])})(p.useMemo((()=>({open:r,close:n,set:o})),[e,r]),t)}function l(e){return n(e,s())}function c(e){let t=s(),r=effector.is.unit(e)||'object'!=typeof e?{event:e}:e;return p.useMemo((()=>{if(effector.is.unit(e))return effector.scopeBind(e,{scope:t});let r=Array.isArray(e)?[]:{};for(let n in e)r[n]=effector.scopeBind(e[n],{scope:t});return r}),[t,...Object.keys(r),...Object.values(r)])}Object.defineProperty(exports,'__esModule',{value:1});var i=require('react'),effector=require('effector'),p=e(i);let f='undefined'!=typeof window?p.useLayoutEffect:p.useEffect,d=e=>{throw Error(e)};const y=(e,t)=>t?t.getState(e):e.getState(),m=(e,t)=>e!==t,v=()=>p.useReducer((e=>e+1),0)[1];let x=e=>console.error(`${e} is deprecated`);const k=p.createContext(null);let{Provider:g}=k,S=e=>t=>{let n=e;return'function'!=typeof e&&(n=t,t=e),r(`Connect(${n.displayName||n.name||'Unknown'})`,(e=>p.createElement(n,{...e,...l(t)})))};exports.Provider=g,exports.connect=S,exports.createComponent=()=>d('not implemented'),exports.createContextComponent=(e,t,r)=>(x('createContextComponent'),n=>{let o=p.useContext(t),u=l(e);return r(n,u,o)}),exports.createGate=(e={})=>(({name:e="gate",domain:t,defaultState:n,hook:o})=>{function u(e){return o(u,e),null}let s=`${t?`${t.compositeName.fullName}/`:''}${e}`,a=effector.createEvent(`${s}.set`),l=effector.createEvent(`${s}.open`),c=effector.createEvent(`${s}.close`),i=effector.createStore(Boolean(0),{name:`${s}.status`}).on(l,(()=>Boolean(1))).on(c,(()=>Boolean(0))),p=effector.createStore(n,{name:`${s}.state`}).on(a,((e,t)=>t)).reset(c);if(t){let{hooks:e}=t;effector.launch({target:[e.store,e.store,e.event,e.event,e.event],params:[i,p,l,c,a]})}return u.open=l,u.close=c,u.status=i,u.state=p,u.set=a,r(`Gate:${s}`,u)})({domain:e.domain,name:e.name,defaultState:'defaultState'in e?e.defaultState:{},hook:a}),exports.createReactState=(e,t)=>(x('createReactState'),S(t)(e)),exports.createStoreConsumer=e=>t=>{let r=l(e);return t.children(r)},exports.useEvent=c,exports.useGate=a,exports.useList=(e,t)=>((e,t,u)=>{let s,a,l=[];'object'==typeof t&&null!==t?(t.keys&&(l=t.keys),s=t.fn,t.getKey&&(a=t.getKey)):s=t,effector.is.store(e)||d('expect useList first argument to be a store'),'function'!=typeof s&&d("expect useList's renderItem to be a function"),Array.isArray(l)||d("expect useList's keys to be an array");let c=p.useMemo((()=>{let t=r(`${e.shortName||'Unknown'}.Item`,(t=>{let{index:r,keys:n,keyVal:s,value:a}=t;if(i.current[1])return i.current[0](a,s);let l=o([{store:e,keys:[r,...n],fn:(e,t)=>e[t[0]]}],u);return i.current[0](l,r)}));return p.memo(t)}),[e,u,!!a]),i=p.useRef([s,a]);i.current=[s,a];let f=p.useMemo((()=>l),l);if(a)return n(e,u).map((e=>{let t=i.current[1](e);return p.createElement(c,{keyVal:t,key:t,keys:f,value:e})}));{let t=o([{store:e,keys:[e],fn:e=>e.length}],u);return Array.from({length:t},((e,t)=>p.createElement(c,{index:t,key:t,keys:f})))}})(e,t,s()),exports.useStore=l,exports.useStoreMap=(e,t)=>{let r=s();return o(t?[e,t]:[{store:e.store,keys:e.keys,fn:e.fn,updateFilter:e.updateFilter}],r)};
//# sourceMappingURL=scope.js.map
