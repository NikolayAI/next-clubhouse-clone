function e(e,t,n){let r=[y.run({fn:e=>t(e)})];if(n){let t=m({node:r}),o=e.graphite.id,u=n.additionalLinks,a=u[o]||[];return u[o]=a,a.push(t),()=>{let e=a.indexOf(t);-1!==e&&a.splice(e,1),k(t)}}{let t=m({node:r,parent:[e],family:{owners:e}});return()=>{k(t)}}}function t(e,t){return t.displayName=e,t}function n(t,n){v.store(t)||S('expect useStore argument to be a store');let r=j(t,n),o=A(),u=d.useRef({store:t,value:r,pending:0});return $((()=>{let r=e(t,(e=>{let t=u.current;t.pending||(t.value=e,t.pending=1,o(),t.pending=0)}),n),a=j(t,n),s=u.current;return s.store===t&&s.value!==a&&(s.value=a,s.pending=1,o(),s.pending=0),s.store=t,r}),[t,n]),r}function r([t,n],r){let u,a,s,l=M;n?(u=n,a=t,s=[]):(u=t.fn,a=t.store,s=t.keys,l=t.updateFilter||M),v.store(a)||S('useStoreMap expects a store'),Array.isArray(s)||S('useStoreMap expects an array as keys'),'function'!=typeof u&&S('useStoreMap expects a function');let c=d.useRef({}),i=c.current;i.fn=u,i.upd=l,i.init=i.store===a,i.store=a;let f=A(),p=[r,...s],y=d.useMemo((()=>(o(j(a,r),s,c.current),e(a,(e=>o(e,s,c.current,f)),r))),p);return $((()=>()=>y()),p),i.val}function o(e,t,n,r){let o=n.fn(e,t);n.init?void 0!==o&&M(o,n.val)&&n.upd(o,n.val)&&(n.val=o,r&&r()):(n.val=o,n.init=1)}function u(){let e=d.useContext(C);return e||S('No scope found, consider adding <Provider> to app root'),e}function a(e={}){return(({name:e="gate",domain:n,defaultState:r,hook:o})=>{function u(e){return o(u,e),null}let a=`${n?`${n.compositeName.fullName}/`:''}${e}`,s=g(`${a}.set`),l=g(`${a}.open`),c=g(`${a}.close`),i=x(Boolean(0),{name:`${a}.status`}).on(l,(()=>Boolean(1))).on(c,(()=>Boolean(0))),f=x(r,{name:`${a}.state`}).on(s,((e,t)=>t)).reset(c);if(n){let{hooks:e}=n;h({target:[e.store,e.store,e.event,e.event,e.event],params:[i,f,l,c,s]})}return u.open=l,u.close=c,u.status=i,u.state=f,u.set=s,t(`Gate:${a}`,u)})({domain:e.domain,name:e.name,defaultState:'defaultState'in e?e.defaultState:{},hook:s})}function s(e,t={}){let[n,r,o]=p([e.open,e.close,e.set]);((e,t={})=>{let n=d.useRef({value:null,count:0});$((()=>(e.open(n.current.value),()=>e.close(n.current.value))),[e]),((e,t)=>{if(e===t)return 1;if('object'==typeof e&&null!==e&&'object'==typeof t&&null!==t){let n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return 0;for(let r=0;r<n.length;r++){let o=n[r];if(e[o]!==t[o])return 0}return 1}return 0})(n.current.value,t)||(n.current.value=t,n.current.count+=1),$((()=>{e.set(n.current.value)}),[n.current.count])})(d.useMemo((()=>({open:n,close:r,set:o})),[e,n]),t)}function l(e){return t=>{let n=c(e);return t.children(n)}}function c(e){return n(e,u())}function i(e,o){return((e,o,u)=>{let a,s,l=[];'object'==typeof o&&null!==o?(o.keys&&(l=o.keys),a=o.fn,o.getKey&&(s=o.getKey)):a=o,v.store(e)||S('expect useList first argument to be a store'),'function'!=typeof a&&S("expect useList's renderItem to be a function"),Array.isArray(l)||S("expect useList's keys to be an array");let c=d.useMemo((()=>{let n=t(`${e.shortName||'Unknown'}.Item`,(t=>{let{index:n,keys:o,keyVal:a,value:s}=t;if(i.current[1])return i.current[0](s,a);let l=r([{store:e,keys:[n,...o],fn:(e,t)=>e[t[0]]}],u);return i.current[0](l,n)}));return d.memo(n)}),[e,u,!!s]),i=d.useRef([a,s]);i.current=[a,s];let f=d.useMemo((()=>l),l);if(s)return n(e,u).map((e=>{let t=i.current[1](e);return d.createElement(c,{keyVal:t,key:t,keys:f,value:e})}));{let t=r([{store:e,keys:[e],fn:e=>e.length}],u);return Array.from({length:t},((e,t)=>d.createElement(c,{index:t,key:t,keys:f})))}})(e,o,u())}function f(e,t){let n=u();return r(t?[e,t]:[{store:e.store,keys:e.keys,fn:e.fn,updateFilter:e.updateFilter}],n)}function p(e){let t=u(),n=v.unit(e)||'object'!=typeof e?{event:e}:e;return d.useMemo((()=>{if(v.unit(e))return b(e,{scope:t});let n=Array.isArray(e)?[]:{};for(let r in e)n[r]=b(e[r],{scope:t});return n}),[t,...Object.keys(n),...Object.values(n)])}import d from'react';import{step as y,createNode as m,clearNode as k,is as v,createEvent as g,createStore as x,launch as h,scopeBind as b}from'effector/effector.mjs';let $='undefined'!=typeof window?d.useLayoutEffect:d.useEffect,S=e=>{throw Error(e)};const j=(e,t)=>t?t.getState(e):e.getState(),M=(e,t)=>e!==t,A=()=>d.useReducer((e=>e+1),0)[1];let w=e=>console.error(`${e} is deprecated`);const C=d.createContext(null);let{Provider:E}=C,N=(e,t,n)=>(w('createContextComponent'),r=>{let o=d.useContext(t),u=c(e);return n(r,u,o)}),R=()=>S('not implemented'),L=(e,t)=>(w('createReactState'),O(t)(e)),O=e=>n=>{let r=e;return'function'!=typeof e&&(r=n,n=e),t(`Connect(${r.displayName||r.name||'Unknown'})`,(e=>d.createElement(r,{...e,...c(n)})))};export{E as Provider,O as connect,R as createComponent,N as createContextComponent,a as createGate,L as createReactState,l as createStoreConsumer,p as useEvent,s as useGate,i as useList,c as useStore,f as useStoreMap};
//# sourceMappingURL=scope.mjs.map
