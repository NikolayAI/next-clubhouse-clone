function e(e){return e&&'object'==typeof e&&'default'in e?e.default:e}function t(e,t,r){let n=[effector.step.run({fn:e=>t(e)})];if(r){let t=effector.createNode({node:n}),o=e.graphite.id,u=r.additionalLinks,a=u[o]||[];return u[o]=a,a.push(t),()=>{let e=a.indexOf(t);-1!==e&&a.splice(e,1),effector.clearNode(t)}}{let t=effector.createNode({node:n,parent:[e],family:{owners:e}});return()=>{effector.clearNode(t)}}}function r(e,t){return t.displayName=e,t}function n(e,r){effector.is.store(e)||p('expect useStore argument to be a store');let n=d(e,r),o=y(),u=i.useRef({store:e,value:n,pending:0});return f((()=>{let n=t(e,(e=>{let t=u.current;t.pending||(t.value=e,t.pending=1,o(),t.pending=0)}),r),a=d(e,r),s=u.current;return s.store===e&&s.value!==a&&(s.value=a,s.pending=1,o(),s.pending=0),s.store=e,n}),[e,r]),n}function o([e,r],n){let o,a,s,l=m;r?(o=r,a=e,s=[]):(o=e.fn,a=e.store,s=e.keys,l=e.updateFilter||m),effector.is.store(a)||p('useStoreMap expects a store'),Array.isArray(s)||p('useStoreMap expects an array as keys'),'function'!=typeof o&&p('useStoreMap expects a function');let c=i.useRef({}),v=c.current;v.fn=o,v.upd=l,v.init=v.store===a,v.store=a;let x=y(),k=[n,...s],g=i.useMemo((()=>(u(d(a,n),s,c.current),t(a,(e=>u(e,s,c.current,x)),n))),k);return f((()=>()=>g()),k),v.val}function u(e,t,r,n){let o=r.fn(e,t);r.init?void 0!==o&&m(o,r.val)&&r.upd(o,r.val)&&(r.val=o,n&&n()):(r.val=o,r.init=1)}function a(e){return n(e)}function s(e,t){function n(e){let r=i.useRef(e),n=a(o);f((()=>(s({props:r.current,state:o.getState()}),()=>{l({props:r.current,state:o.getState()})})),[]);let u=t(e,n);return r.current=e,u}let o;effector.is.store(e)?o=e:'object'==typeof e&&null!==e?o=effector.combine(e):p('shape should be a store or object with stores');let u='Unknown';o&&o.shortName&&(u=o.shortName);let s=effector.createEvent(),l=effector.createEvent();return n.mounted=s,n.unmounted=l,r(`${u}.View`,n)}function l(e,t={}){let r=i.useRef({value:null,count:0});f((()=>(e.open(r.current.value),()=>e.close(r.current.value))),[e]),((e,t)=>{if(e===t)return 1;if('object'==typeof e&&null!==e&&'object'==typeof t&&null!==t){let r=Object.keys(e),n=Object.keys(t);if(r.length!==n.length)return 0;for(let n=0;n<r.length;n++){let o=r[n];if(e[o]!==t[o])return 0}return 1}return 0})(r.current.value,t)||(r.current.value=t,r.current.count+=1),f((()=>{e.set(r.current.value)}),[r.current.count])}Object.defineProperty(exports,'__esModule',{value:1});var c=require('react'),effector=require('effector'),i=e(c);let f='undefined'!=typeof window?i.useLayoutEffect:i.useEffect,p=e=>{throw Error(e)};const d=(e,t)=>t?t.getState(e):e.getState(),m=(e,t)=>e!==t,y=()=>i.useReducer((e=>e+1),0)[1];let v=e=>console.error(`${e} is deprecated`),x=e=>t=>{let n=e;return'function'!=typeof e&&(n=t,t=e),r(`Connect(${n.displayName||n.name||'Unknown'})`,(e=>i.createElement(n,{...e,...a(t)})))};exports.connect=x,exports.createComponent=s,exports.createContextComponent=(e,t,n)=>(v('createContextComponent'),r(`${e.shortName||'Unknown'}.ContextComponent`,(r=>{let o=i.useContext(t),u=a(e);return n(r,u,o)}))),exports.createGate=(e="gate",t={})=>{let n;return'object'==typeof e&&null!==e&&('defaultState'in e&&(t=e.defaultState),e.domain&&(n=e.domain),e=e.name),(({name:e="gate",domain:t,defaultState:n,hook:o})=>{function u(e){return o(u,e),null}let a=`${t?`${t.compositeName.fullName}/`:''}${e}`,s=effector.createEvent(`${a}.set`),l=effector.createEvent(`${a}.open`),c=effector.createEvent(`${a}.close`),i=effector.createStore(Boolean(0),{name:`${a}.status`}).on(l,(()=>Boolean(1))).on(c,(()=>Boolean(0))),f=effector.createStore(n,{name:`${a}.state`}).on(s,((e,t)=>t)).reset(c);if(t){let{hooks:e}=t;effector.launch({target:[e.store,e.store,e.event,e.event,e.event],params:[i,f,l,c,s]})}return u.open=l,u.close=c,u.status=i,u.state=f,u.set=s,r(`Gate:${a}`,u)})({name:e,domain:n,defaultState:t,hook:l})},exports.createReactState=(e,t)=>(v('createReactState'),x(t)(e)),exports.createStoreConsumer=e=>s(e,(({children:e},t)=>e(t))),exports.useEvent=e=>e,exports.useGate=l,exports.useList=(e,t)=>((e,t,u)=>{let a,s,l=[];'object'==typeof t&&null!==t?(t.keys&&(l=t.keys),a=t.fn,t.getKey&&(s=t.getKey)):a=t,effector.is.store(e)||p('expect useList first argument to be a store'),'function'!=typeof a&&p("expect useList's renderItem to be a function"),Array.isArray(l)||p("expect useList's keys to be an array");let c=i.useMemo((()=>{let t=r(`${e.shortName||'Unknown'}.Item`,(t=>{let{index:r,keys:n,keyVal:a,value:s}=t;if(f.current[1])return f.current[0](s,a);let l=o([{store:e,keys:[r,...n],fn:(e,t)=>e[t[0]]}],u);return f.current[0](l,r)}));return i.memo(t)}),[e,u,!!s]),f=i.useRef([a,s]);f.current=[a,s];let d=i.useMemo((()=>l),l);if(s)return n(e,u).map((e=>{let t=f.current[1](e);return i.createElement(c,{keyVal:t,key:t,keys:d,value:e})}));{let t=o([{store:e,keys:[e],fn:e=>e.length}],u);return Array.from({length:t},((e,t)=>i.createElement(c,{index:t,key:t,keys:d})))}})(e,t),exports.useStore=a,exports.useStoreMap=(e,t)=>o([e,t]);
//# sourceMappingURL=effector-react.cjs.js.map
