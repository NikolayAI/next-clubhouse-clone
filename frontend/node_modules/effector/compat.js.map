{"version":3,"file":"compat.js","sources":["effector/collection.ts","effector/throw.ts","effector/region.ts","effector/createNode.ts","effector/tag.ts","effector/kernel.ts","effector/naming.ts","effector/config.ts","effector/template.ts","effector/createUnit.ts","effector/combine.ts","effector/defer.ts","effector/createEffect.ts","effector/merge.ts","effector/sample.ts","effector/fork/util.ts","effector/observable.ts","effector/validate.ts","effector/is.ts","effector/id.ts","effector/step.ts","effector/stateRef.ts","effector/caller.ts","effector/getter.ts","effector/own.ts","effector/clearNode.ts","effector/subscription.ts","effector/forward.ts","effector/watch.ts","effector/split.ts","effector/fork/allSettled.ts","effector/attach.ts","effector/createApi.ts","effector/createDomain.ts","effector/fork/fork.ts","effector/fork/createScope.ts","effector/fromObservable.ts","effector/guard.ts","effector/fork/hydrate.ts","effector/restore.ts","effector/fork/scopeBind.ts","effector/fork/serialize.ts"],"sourcesContent":["export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = (list: any[], item: any) => list.includes(item)\n\nexport const removeItem = (list: any[], item: any) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(condition: any, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: any,\n  subject: string,\n  suggestion: string,\n) =>\n  !condition &&\n  console.error(`${subject} is deprecated, use ${suggestion} instead`)\n","import {getParent, getMeta} from './getter'\nimport {createNode} from './createNode'\nimport type {Template} from '../forest/index.h'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: any\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion(unit: any, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: getMeta(unit, 'template') || readTemplate(),\n    sidRoot: getMeta(unit, 'sidRoot') || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), name, loc, method},\n  })\n  return withRegion(sidNode, fn)\n}\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nconst arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {STORE, EFFECT, SAMPLER, STACK, BARRIER, VALUE, REG_A, MAP} from './tag'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\nexport type Stack = {\n  value: any\n  a: any\n  b: any\n  c?: any\n  parent: Stack | null\n  node: Node\n  page: Leaf | null\n  scope?: Scope | null | void\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  scope?: Scope | null | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case BARRIER:\n      return 3\n    case SAMPLER:\n      return 4\n    case EFFECT:\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void\n  stack?: Stack | void\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {isRoot, currentPage, scope: forkPage, isWatch}\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = getMeta(node, 'op') === 'watch'\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem(\n          'child',\n          page,\n          nextNode,\n          stack,\n          finalValue,\n          getForkPage(stack),\n        )\n      })\n      const forkPage = getForkPage(stack)\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nexport const initRefInScope = (\n  scope: {\n    reg: Record<string, StateRef>\n    sidValuesMap: Record<string, any>\n    sidIdMap: Record<string, string>\n  },\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  const sid = sourceRef.sid\n  if (refsMap[sourceRef.id]) return\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n  }\n\n  if (sid && sid in scope.sidValuesMap && !(sid in scope.sidIdMap)) {\n    ref.current = scope.sidValuesMap[sid]\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              const value = from && refsMap[from.id].current\n              if (needToAssign) {\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import type {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\nimport {forIn} from './collection'\n\nconst getCompostite = (unit: any): CompositeName => unit.compositeName\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, (unit: any) => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit) ? getCompostite(unit).fullName : unit.toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompostite(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompostite(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg: any,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args: any[]): [any[], any | void]\nexport function processArgsToConfig(\n  args: any,\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  if (rawConfig.and) {\n    args = rawConfig.and\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part: any, config: any = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn: any = template.handlers[method]\n    if (fn) return fn(template, ...args)\n  }\n}\n","import {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport type {Store, Event} from './unit.h'\n\nimport {calc, compute, filter, mov, read} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n} from './kernel'\n\nimport type {Subscriber, Config} from './index.h'\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\n\nexport const applyParentHook = (\n  source: any,\n  target: any,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind: any, unit: any, configA: any, configB?: any) => {\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const config = flattenConfig({\n    or: configB,\n    and: typeof configA === 'string' ? {name: configA} : configA,\n  })\n  const {parent = null, sid = null, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => {\n    deprecate(false, 'thru', 'js pipe')\n    return fn(unit)\n  }\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (event: any, op: string, fn: any, node: any) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName} → *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate(unit: any, template: any, payload: any, args: any[]): any {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) => {\n    deprecate(\n      !getMeta(event, 'derived'),\n      'call of derived event',\n      'createEvent',\n    )\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }\n  const template = readTemplate()\n  return Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(EVENT, event, nameOrConfig, maybeConfig),\n      regional: true,\n    }),\n    create(params: any, _: any) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: any) => deriveEvent(event, MAP, fn, [compute({fn: callStack})]),\n    filter: (fn: any) =>\n      deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [filter({fn: callStack})]),\n    filterMap: (fn: any) =>\n      deriveEvent(event, 'filterMap', fn, [\n        compute({fn: callStack}),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: any) {\n      const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(\n        contramapped,\n        event,\n        [compute({fn: callStack})],\n        'prepend',\n        fn,\n      )\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: any) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: any[]) {\n      forEach(units, unit => store.on(unit, () => store.defaultState))\n      return store\n    },\n    on(nodeSet: any, fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      deprecate(\n        !getMeta(store, 'derived'),\n        '.on in derived store',\n        'createStore',\n      )\n      forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n        store.off(trigger)\n        getSubscribers(store).set(\n          trigger,\n          createSubscription(\n            updateStore(trigger, store, 'on', callARegStack, fn),\n          ),\n        )\n      })\n      return store\n    },\n    off(unit: any) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = fn.fn\n      }\n      deprecate(\n        isVoid(firstState),\n        'second argument of store.map',\n        'updateFilter',\n      )\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!isVoid(storeState)) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName} → *`,\n        derived: true,\n        and: config,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStackAReg, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function')\n      return eventOrFn.watch((payload: any) => fn(store.getState(), payload))\n    },\n  }\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => !isVoid(upd) && (upd !== a || b), true),\n      updateFilter && filter({fn: callStackAReg}),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    if (getMeta(store, 'serialize') !== 'ignore')\n      setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n  }\n  assert(\n    getMeta(store, 'derived') || !isVoid(defaultState),\n    \"current state can't be undefined, use null instead\",\n  )\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: any,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, compute({fn: caller})]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, compute, calc, read} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport {callStack} from './caller'\nimport type {Config} from './index.h'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = (list: any[]) => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), 'shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj: any,\n  config?: Config,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => list.slice() : (obj: any) => ({...obj})\n  const defaultState: any = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    read(rawShape),\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: BARRIER,\n      batch: true,\n    }),\n    read(rawShape, true),\n    fn && compute({fn: callStack}),\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args: any[]) {\n  deprecate(false, 'createStoreObject', 'combine')\n  return combine(...args)\n}\n","export function createDefer(): {\n  rs: (value: any) => any\n  rj: (value: any) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value: any) => any\n    rj: (value: any) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch, Stack} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport type {Unit} from './index.h'\nimport {add} from './collection'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig?: any,\n) {\n  const instance: any = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  )\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function')\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}: any) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}: any) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: any) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: any) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handlerId: getMeta(node, 'sid'),\n      handler:\n        instance.defaultConfig.handler ||\n        (() => assert(false, `no handler used in ${instance.getType()}`)),\n    },\n    node: [\n      calc(\n        (upd, scope_, stack) => {\n          const scope: {handlerId: string; handler: Function} = scope_ as any\n          let handler = scope.handler\n          if (getForkPage(stack)) {\n            const handler_ = getForkPage(stack)!.handlers[scope.handlerId]\n            if (handler_) handler = handler_\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        ({params, req, handler, args = [params]}, _, stack) => {\n          const onResolve = onSettled(params, req, true, anyway, stack)\n          const onReject = onSettled(params, req, false, anyway, stack)\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc(\n      (params, {runner}, stack) => {\n        const upd = getParent(stack)\n          ? {params, req: {rs(data: any) {}, rj(data: any) {}}}\n          : /** empty stack means that this node was launched directly */\n            params\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          scope: getForkPage(stack),\n        })\n        return upd.params\n      },\n      false,\n      true,\n    ),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch({target: instance, params: payload, scope: forkPage})\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data: any) => void,\n  args: any[],\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const onSettled =\n  (\n    params: any,\n    req: {\n      rs(_: any): any\n      rj(_: any): any\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n  ) =>\n  (data: any) =>\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      page: stack.page,\n      scope: getForkPage(stack),\n    })\n\nexport const sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  events: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const result = createEvent(config || unitObjectName(events, 'merge'))\n  assertNodeSet(events, 'merge', 'first argument')\n  createLinkNode(events, result, [], 'merge')\n  return result\n}\n","import {combine} from './combine'\nimport {mov, compute, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {own} from './own'\nimport {assertNodeSet, is, isObject, isVoid} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\nimport {forEach} from './collection'\nimport {SAMPLE, STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config: any, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\nexport const groupInputs = (source: any, clock: any, method: string) => {\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(method, 'either source or clock'),\n  )\n  if (isVoid(source)) {\n    assertNodeSet(clock, method, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  return [source, clock] as const\n}\nexport function sample(...args: any): any {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batched = true\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, 'sample')\n  ) {\n    clock = source.clock\n    fn = source.fn\n    batched = !source.greedy\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  ;[source, clock] = groupInputs(source, clock, 'sample')\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  }\n  assertNodeSet(clock, 'sample', 'clock')\n  if (!metadata && !name) name = source.shortName\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent(name, metadata)\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    const sourceRef = getStoreState(source)\n    own(source, [\n      createLinkNode(\n        clock,\n        target,\n        [\n          applyTemplate('sampleSourceLoader'),\n          read(sourceRef, !fn, batched),\n          fn && compute({fn: callARegStack}),\n          applyTemplate('sampleSourceUpward', isUpward),\n        ],\n        SAMPLE,\n        fn,\n        // scope: {fn, targetTemplate}\n      ),\n    ])\n    applyTemplate('sampleStoreSource', sourceRef)\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceRef = createStateRef()\n    const clockState = createStateRef()\n    applyTemplate('sampleNonStoreSource', hasSource, sourceRef, clockState)\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: SAMPLE},\n      regional: true,\n    })\n    own(source, [\n      createLinkNode(\n        clock,\n        target,\n        [\n          applyTemplate('sampleSourceLoader'),\n          mov({from: STACK, target: clockState}),\n          read(hasSource, true),\n          calc(hasSource => hasSource, true),\n          read(sourceRef, true, batched),\n          read(clockState),\n          fn && compute({fn: callStackAReg}),\n          applyTemplate('sampleSourceUpward', isUpward),\n        ],\n        SAMPLE,\n        fn,\n        // scope: {fn, targetTemplate}\n      ),\n    ])\n  }\n  return target\n}\n","import {getMeta, getOwners, getLinks} from '../getter'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport type {Store} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {STORE} from '../tag'\n\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n) {\n  const list = [] as Node[]\n  ;(function visit(node) {\n    if (includes(list, node)) return\n    add(list, node)\n    if (getMeta(node, 'op') === STORE && getMeta(node, 'sid')) {\n      fn(node, getMeta(node, 'sid'))\n    }\n    forEach(node.next, visit)\n    forEach(getOwners(node), visit)\n    forEach(getLinks(node), visit)\n  })(root)\n}\n\nexport function normalizeValues(\n  values: Map<Store<any>, any> | Array<[any, any]> | Record<string, any>,\n  assertEach?: (key: any, value: any) => void,\n) {\n  if (Array.isArray(values)) values = new Map(values)\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    forEach(values, (value, key) => {\n      assert(is.unit(key), 'Map key should be a unit')\n      if (assertEach) assertEach(key, value)\n      assert(key.sid, 'unit should have a sid')\n      assert(!(key.sid! in result), 'duplicate sid found')\n      result[key.sid!] = value\n    })\n    return result\n  }\n  return values\n}\n","export const observableSymbol: any =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {Domain, Effect, Event, Scope, Store} from './unit.h'\n\nexport const unit = (obj: any) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: any) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value: any) => value is Store<unknown>\nexport const event = is(EVENT) as (value: any) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value: any,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value: any) => value is Domain\nexport const scope = is(SCOPE) as (value: any) => value is Scope\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const isVoid = (value: any) => value === undefined\n\nexport const assertObject = (value: any) =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value: any,\n  method: string,\n  valueName: string,\n  reason: string,\n) =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (\n  value: any,\n  method: string,\n  valueName: string,\n) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag, Stack} from './kernel'\n\nconst cmd = (\n  type: 'compute' | 'mov',\n  data: any,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result: any = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = ({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n}: {\n  fn?: (data: any, scope: {[key: string]: any}, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n}): Compute => cmd('compute', {fn, safe, filter}, priority, batch)\n\nexport const filter = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, filter: true})\n\nexport const run = ({\n  fn,\n}: {\n  fn(data: any, scope: {[key: string]: any}, stack: Stack): any\n}) => compute({fn, priority: EFFECT})\n\nexport const calc = (\n  fn: (data: any, scope: {[key: string]: any}, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import type {Stack} from './kernel'\n\nexport const callStackAReg = (stack: any, {fn}: any, {a}: Stack) => fn(stack, a)\nexport const callARegStack = (stack: any, {fn}: any, {a}: Stack) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: any, _: Stack) => fn(stack)\n","import type {Node, StateRef} from './index.h'\nimport type {Scope} from './unit.h'\n\nexport const getGraph = (graph: any): Node => graph.graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: any): StateRef => store.stateRef\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: any) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any): Scope | void => val.scope\nexport const getMeta = (unit: any, field: string) => getGraph(unit).meta[field]\nexport const setMeta = (unit: any, field: string, value: any) =>\n  (getGraph(unit).meta[field] = value)\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-ignore\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && getMeta(targetNode, 'op') !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-ignore\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    //@ts-ignore\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  assertNodeSet(from, 'forward', '\"from\"')\n  assertNodeSet(to, 'forward', '\"to\"')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: 'forward', config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n","import type {Event} from './unit.h'\nimport type {NodeUnit, Cmd} from './index.h'\nimport {is, isFunction, isObject} from './is'\nimport {add, forIn, includes} from './collection'\nimport {addRefOp, createStateRef} from './stateRef'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {compute, filter, calc, read} from './step'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {assert} from './throw'\nimport {createEvent} from './createUnit'\nimport {applyTemplate} from './template'\n\nconst launchCase = (\n  scopeTargets: Record<string, NodeUnit>,\n  field: string,\n  data: any,\n  stack: any,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]): any {\n  let targets: Record<string, Event<any> | NodeUnit>\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const knownCases = !match\n  if (knownCases) {\n    targets = source.cases\n    match = source.match\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  if (!targets!) targets = {}\n  if (!knownCases) {\n    assert(matchIsShape, 'match should be an object')\n    forIn(match, (_, key) => (targets[key] = createEvent(metadata)))\n    targets.__ = createEvent(metadata)\n  }\n  const owners = new Set(\n    ([] as NodeUnit[]).concat(source, Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && read(getStoreState(match), false, true),\n      compute({\n        safe: matchIsUnit,\n        filter: true,\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn: any, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        add(units, key)\n        owners.add(storeOrFn)\n        const updater = createLinkNode(\n          storeOrFn,\n          [],\n          [read(lastValues), calc((upd, _, {a}) => (a[key] = upd))],\n        )\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          addRefOp(lastValues, {from: storeRef, field: key, type: 'field'})\n          applyTemplate('splitMatchStore', storeRef, updater)\n        }\n      }\n    })\n    if (needBarrier!) {\n      applyTemplate('splitBase', lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && read(lastValues, false, true),\n      filter({\n        fn(data, scopeTargets, stack) {\n          for (let i = 0; i < caseNames.length; i++) {\n            const caseName = caseNames[i]\n            const caseValue = includes(units, caseName)\n              ? stack.a[caseName]\n              : match[caseName](data)\n            if (caseValue) {\n              launchCase(scopeTargets, caseName, data, stack)\n              return\n            }\n          }\n          launchCase(scopeTargets, '__', data, stack)\n        },\n      }),\n    ]\n  } else {\n    assert(false, 'expect match to be unit, function or object')\n  }\n  createNode({\n    meta: {op: 'split'},\n    parent: source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {owners: Array.from(owners)},\n    regional: true,\n  })\n  if (!knownCases) return targets\n}\n","import {add} from '../collection'\nimport {createDefer} from '../defer'\nimport {is} from '../is'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\nexport function allSettled(\n  start: any,\n  {scope, params: ctx}: {scope: Scope; params?: any},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-expect-error\n  defer.parentFork = forkPage\n  const {fxCount} = scope\n  add(fxCount.scope.defers, defer)\n\n  const launchUnits = [start]\n  const launchParams = [] as Array<{params: any; req: any} | null>\n  add(\n    launchParams,\n    is.effect(start)\n      ? {\n          params: ctx,\n          req: {\n            rs(value: any) {\n              //@ts-ignore\n              defer.value = {status: 'done', value}\n            },\n            rj(value: any) {\n              //@ts-ignore\n              defer.value = {status: 'fail', value}\n            },\n          },\n        }\n      : ctx,\n  )\n  add(launchUnits, fxCount)\n  add(launchParams, null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    scope,\n  })\n  return defer.req\n}\n","import {combine} from './combine'\nimport {createEffect, onSettled, runFn} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {processArgsToConfig} from './config'\nimport {getGraph, getStoreState, setMeta} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {read, calc} from './step'\nimport {launch} from './kernel'\nimport {EFFECT} from './tag'\n\nexport function attach(config: any) {\n  let injected\n  ;[config, injected] = processArgsToConfig(config, true)\n  let {source, effect, mapParams} = config\n  const attached = createEffect(config, injected)\n  setMeta(attached, 'attached', true)\n  const {runner} = getGraph(attached).scope\n  let runnerSteps\n  const runnerFnStep = calc(\n    (upd, _, stack) => {\n      const {params, req, handler} = upd\n      const anyway = attached.finally\n      const rj = onSettled(params, req, false, anyway, stack)\n      const sourceData = stack.a\n      const isEffectHandler = is.effect(handler)\n      let ok = true\n      let computedParams: any\n      if (mapParams) {\n        ;[ok, computedParams] = runFn(mapParams, rj, [params, sourceData])\n      } else {\n        computedParams = source && isEffectHandler ? sourceData : params\n      }\n      if (ok) {\n        if (isEffectHandler) {\n          launch({\n            target: handler as any,\n            params: {\n              params: computedParams,\n              req: {rs: onSettled(params, req, true, anyway, stack), rj},\n            },\n            page: stack.page,\n            defer: true,\n          })\n        } else {\n          upd.args = [sourceData, computedParams]\n          return true\n        }\n      }\n    },\n    true,\n    true,\n  )\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(state, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    runnerSteps = [read(getStoreState(state)), runnerFnStep]\n  } else {\n    runnerSteps = [runnerFnStep]\n  }\n  runner.seq.splice(1, 0, ...runnerSteps)\n  attached.use(effect)\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import type {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import type {Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport type {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {createLinkNode} from './forward'\nimport {add, forEach, forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {calc} from './step'\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const node = createNode({family: {type: DOMAIN}, regional: true})\n\n  const result: any = {\n    history: {},\n    graphite: node,\n    hooks: {},\n  }\n\n  node.meta = initUnit(DOMAIN, result, nameOrConfig, maybeConfig)\n\n  forIn(\n    {\n      Event: createEvent,\n      Effect: createEffect,\n      Store: createStore,\n      Domain: createDomain,\n    },\n    (factory: any, tag) => {\n      const lowerCaseTag = tag.toLowerCase()\n\n      const trigger = createNamedEvent(`on${tag}`)\n      result.hooks[lowerCaseTag] = trigger\n\n      const acc = new Set<any>()\n      result.history[`${lowerCaseTag}s`] = acc\n\n      trigger.create = res => {\n        launch(trigger, res)\n        return res\n      }\n      add(\n        getGraph(trigger).seq,\n        calc((upd, _, stack) => {\n          stack.scope = null\n          return upd\n        }),\n      )\n      trigger.watch(data => {\n        own(result, [data])\n        acc.add(data)\n        if (!data.ownerSet) data.ownerSet = acc\n        if (!getParent(data)) data.parent = result\n      })\n      own(result, [trigger])\n\n      result[`onCreate${tag}`] = (hook: (data: any) => any) => {\n        forEach(acc, hook)\n        return trigger.watch(hook)\n      }\n      result[`create${tag}`] = result[lowerCaseTag] = (\n        nameOrConfig: any,\n        config?: Config,\n      ) => trigger(factory(nameOrConfig, {parent: result, or: config}))\n    },\n  )\n\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from: NodeUnit, key) =>\n      createLinkNode(from, parent.hooks[key]),\n    )\n  }\n  return result\n}\n","import {is} from '../is'\nimport {assert} from '../throw'\nimport type {Domain} from '../unit.h'\nimport {normalizeValues} from './util'\nimport {createScope} from './createScope'\n\nexport function fork(\n  domainOrConfig?: Domain | {values?: any; handlers?: any},\n  optiionalConfig?: {values?: any; handlers?: any},\n) {\n  let config: {values?: any; handlers?: any} | void = domainOrConfig as any\n  let domain: Domain\n  if (is.domain(domainOrConfig)) {\n    domain = domainOrConfig\n    config = optiionalConfig\n  }\n\n  const scope = createScope(domain!)\n\n  if (config) {\n    if (config.values) {\n      const valuesSidMap = normalizeValues(config.values, unit =>\n        assert(is.store(unit), 'Values map can contain only stores as keys'),\n      )\n      Object.assign(scope.sidValuesMap, valuesSidMap)\n    }\n    if (config.handlers) {\n      scope.handlers = normalizeValues(config.handlers, unit =>\n        assert(\n          is.effect(unit),\n          `Handlers map can contain only effects as keys`,\n        ),\n      )\n    }\n  }\n  return scope\n}\n","import {getForkPage, getGraph, getMeta, getParent} from '../getter'\nimport {setForkPage, getPageRef, currentPage} from '../kernel'\nimport {createNode} from '../createNode'\nimport {calc, compute} from '../step'\nimport type {Domain, Scope} from '../unit.h'\nimport type {StateRef} from '../index.h'\nimport {forEach} from '../collection'\nimport {DOMAIN, SAMPLER, SCOPE} from '../tag'\n\nexport function createScope(unit?: Domain): Scope {\n  const forkInFlightCounter = createNode({\n    scope: {\n      defers: [],\n      inFlight: 0,\n      fxID: 0,\n    },\n    node: [\n      calc((_, scope, stack) => {\n        if (!getParent(stack)) {\n          scope.fxID += 1\n          return\n        }\n        if (getMeta(getParent(stack).node, 'needFxCounter') === 'dec') {\n          scope.inFlight -= 1\n        } else {\n          scope.inFlight += 1\n          scope.fxID += 1\n        }\n      }),\n      compute({priority: SAMPLER, batch: true}),\n      calc(\n        (_, scope) => {\n          const {defers, fxID} = scope\n          if (scope.inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), (defer: any) => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n        false,\n        true,\n      ),\n    ],\n  })\n  const page = {} as Record<string, StateRef>\n  const storeChange = createNode({\n    node: [\n      calc((value, __, stack) => {\n        const storeStack = getParent(stack)\n        if (storeStack && getParent(storeStack)) {\n          const storeNode = storeStack.node\n          if (\n            !getMeta(storeNode, 'isCombine') ||\n            getMeta(getParent(storeStack).node, 'op') !== 'combine'\n          ) {\n            const forkPage = getForkPage(stack)!\n            const id = storeNode.scope.state.id\n            const sid = getMeta(storeNode, 'sid')\n            forkPage.sidIdMap[sid] = id\n            forkPage.sidValuesMap[sid] = value\n          }\n        }\n      }),\n    ],\n  })\n  const resultScope: Scope = {\n    cloneOf: unit,\n    reg: page,\n    sidValuesMap: {},\n    sidIdMap: {},\n    getState(store: any) {\n      if ('current' in store) {\n        return getPageRef(currentPage, resultScope, null, store).current\n      }\n      const node = getGraph(store)\n      return getPageRef(currentPage, resultScope, node, node.scope.state, true)\n        .current\n    },\n    kind: SCOPE,\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, storeChange],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n    additionalLinks: {},\n    handlers: {},\n    fxCount: forkInFlightCounter,\n    storeChange,\n  }\n  return resultScope\n}\n","import {observableSymbol} from './observable'\nimport type {Event} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {assertObject} from './is'\nimport {assert} from './throw'\nimport {createSubscription} from './subscription'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  assert(observableItem.subscribe, 'expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = createSubscription(event)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import {processArgsToConfig} from './config'\nimport {createLinkNode} from './forward'\nimport {groupInputs, validateSampleConfig, sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {calc, filter} from './step'\nimport {callStack} from './caller'\nimport {assertNodeSet, is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\n\nexport function guard(...args: any[]) {\n  const METHOD = 'guard'\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  validateSampleConfig(config, METHOD)\n  let {\n    filter: filterFn,\n    greedy,\n    clock,\n    name = metadata && metadata.name ? metadata.name : METHOD,\n  } = config\n  const target = config.target || createEvent(name, metadata)\n  const filterIsUnit = is.unit(filterFn)\n  ;[source, clock] = groupInputs(source, clock, METHOD)\n  if (clock) {\n    assertNodeSet(clock, METHOD, 'clock')\n    source = sample({\n      source,\n      clock,\n      greedy,\n      fn: filterIsUnit ? null : (source: any, clock: any) => ({source, clock}),\n    })\n  }\n  assertNodeSet(target, METHOD, 'target')\n  if (filterIsUnit) {\n    sample({\n      source: filterFn,\n      clock: source,\n      target: createNode({\n        node: [calc(({guard}) => guard, true), calc(({data}) => data)],\n        child: target,\n        meta: {op: METHOD},\n        family: {\n          owners: [source, filterFn, target, ...[].concat(clock ? clock : [])],\n          links: target,\n        },\n        regional: true,\n      }),\n      fn: (guard: any, data: any) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    assert(isFunction(filterFn), '`filter` should be function or unit')\n    createLinkNode(\n      source,\n      target,\n      clock\n        ? [\n            filter({fn: ({source, clock}, {fn}) => fn(source, clock)}),\n            calc(({source}) => source),\n          ]\n        : [filter({fn: callStack})],\n      METHOD,\n      filterFn,\n    )\n  }\n  return target\n}\n","import {is, isObject} from '../is'\nimport {assert} from '../throw'\nimport {launch} from '../kernel'\nimport type {Domain, Scope} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, includes} from '../collection'\nimport {normalizeValues, traverseStores} from './util'\nimport {getGraph} from '../getter'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain | Scope, {values}: {values: any}) {\n  assert(isObject(values), 'values property should be an object')\n  const normalizedValues = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(normalizedValues)\n  const storeNodes: Node[] = []\n  const storeValues: any[] = []\n  let forkPage: Scope\n  let traverseTarget: Node\n  let needToAssign: true | void\n  if (is.scope(domain)) {\n    forkPage = domain\n    needToAssign = true\n    assert(forkPage.cloneOf, 'scope should be created from domain')\n    traverseTarget = getGraph(forkPage.cloneOf)\n  } else if (is.domain(domain)) {\n    traverseTarget = getGraph(domain)\n  } else {\n    assert(false, 'first argument of hydrate should be domain or scope')\n  }\n  traverseStores(traverseTarget!, (node, sid) => {\n    // forkPage.sidIdMap[sid] = node.scope.state.id\n    if (includes(valuesSidList, sid)) {\n      add(storeNodes, node)\n      add(storeValues, normalizedValues[sid])\n    }\n  })\n  launch({\n    target: storeNodes,\n    params: storeValues,\n    scope: forkPage!,\n  })\n  if (needToAssign) {\n    Object.assign(forkPage!.sidValuesMap, normalizedValues)\n  }\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {createLinkNode} from './forward'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) return obj\n  if (is.event(obj) || is.effect(obj)) {\n    const domain = getParent(obj)\n    const result = createStore(defaultState, {\n      parent: domain,\n      name: obj.shortName,\n      and: config,\n    })\n    createLinkNode(is.effect(obj) ? obj.doneData : obj, result)\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(\n    obj,\n    (value, key) =>\n      (result[key] = is.store(value) ? value : createStore(value, {name: key})),\n  )\n  return result\n}\n","import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\n/** bind event to scope */\nexport function scopeBind(unit: any, {scope}: {scope?: Scope} = {}) {\n  assert(\n    scope || forkPage,\n    'scopeBind cannot be called outside of forked .watch',\n  )\n  const savedForkPage = scope || forkPage!\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: unit,\n          params: {\n            params,\n            req,\n          },\n          scope: savedForkPage,\n        })\n        return req.req\n      }\n    : (params: any) => {\n        launch({target: unit, params, scope: savedForkPage})\n        return params\n      }\n}\n","import type {Scope, Store} from '../unit.h'\nimport {forIn, includes} from '../collection'\nimport {assert} from '../throw'\nimport {traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\n/**\n serialize state on server\n */\nexport function serialize(\n  scope: Scope,\n  config: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  const ignoredStores = config.ignore ? config.ignore.map(({sid}) => sid) : []\n  const result = {} as Record<string, any>\n  forIn(scope.sidValuesMap, (value, sid) => {\n    if (includes(ignoredStores, sid)) return\n    const id = scope.sidIdMap[sid]\n    // if (!scope.changedStores.has(id)) return\n    if (id && id in scope.reg) {\n      result[sid] = scope.reg[id].current\n    } else {\n      result[sid] = value\n    }\n  })\n  if ('onlyChanges' in config && !config.onlyChanges) {\n    assert(scope.cloneOf, 'scope should be created from domain')\n    traverseStores(getGraph(scope.cloneOf), (node, sid) => {\n      if (\n        !(sid in result) &&\n        !includes(ignoredStores, sid) &&\n        !getMeta(node, 'isCombine') &&\n        getMeta(node, 'serialize') !== 'ignore'\n      )\n        result[sid] = scope.getState(node as any)\n    })\n  }\n  return result\n}\n"],"names":["forIn","obj","cb","key","forEach","list","fn","assert","condition","message","Error","withRegion","unit","regionStack","parent","value","template","getMeta","readTemplate","sidRoot","getParent","createNode","node","child","to","target","scope","meta","family","familyRaw","type","regional","sources","arrifyNodes","from","source","links","owners","seq","item","add","result","id","nextNodeID","next","link","getOwners","owner","getLinks","own","getValue","launch","payload","upsert","pageForLaunch","currentPage","stackForLaunch","forkPageForLaunch","forkPage","params","defer","page","getForkPage","Array","isArray","i","length","pushFirstHeapItem","getGraph","isRoot","stop","skip","reg","lastStartedState","isWatch","idx","stack","hasPageReg","hasScopeReg","local","fail","stepn","step","order","priority","barrierID","fullID","barriers","has","pushHeap","delete","data","STACK","store","pageForRef","getPageForRef","initRefInScope","softRead","undefined","readRef","getPageRef","current","computationResult","safe","tryRun","filter","finalValue","nextNode","fxCount","storeChange","additionalLinks","deleteMin","unitObjectName","objOrArr","method","name","comma","is","getCompostite","fullName","toString","createName","path","shortName","composite","concat","processArgsToConfig","args","singleArgument","rawConfig","assertObject","and","or","applyTemplate","handlers","callCreate","oldPage","setCurrentPage","create","createEvent","nameOrConfig","maybeConfig","event","deprecate","Object","assign","graphite","initUnit","watch","watchUnit","map","deriveEvent","MAP","compute","callStack","filterMap","calc","isVoid","prepend","contramapped","createLinkNode","applyParentHook","createStore","defaultState","props","plainState","createStateRef","updates","createNamedEvent","plainStateId","subscribers","Map","stateRef","getState","reachedPage","targetRef","setState","state","reset","units","on","nodeSet","assertNodeSet","trigger","off","getSubscribers","set","createSubscription","updateStore","callARegStack","currentSubscription","get","firstState","config","lastResult","isObject","storeState","innerStore","derived","linkNode","callStackAReg","addRefOp","getStoreState","noInit","eventOrFn","subscription","isFunction","updateFilter","defaultConfig","upd","_","b","read","a","mov","sid","setMeta","combine","handler","stores","structStoreShape","shapeReady","noArraySpread","rawHandler","slice","storeCombination","createDefer","req","Promise","rs","rj","catch","createEffect","instance","kind","use","runner","getCurrent","anyway","finally","done","named","status","error","doneData","failData","handlerId","getType","scope_","handler_","onResolve","onSettled","onReject","runFn","then","op","fx","savedFork","setForkPage","inFlight","x","pending","amount","merge","events","validateSampleConfig","atLeastOneFieldExists","sampleConfigFields","field","fieldErrorMessage","sample","clock","metadata","batched","greedy","groupInputs","isUpward","initialState","sourceRef","hasSource","clockState","traverseStores","root","visit","includes","normalizeValues","values","assertEach","observableSymbol","Symbol","observable","effect","domain","removeItem","pos","indexOf","splice","push","subject","suggestion","console","assertNodeSetItem","valueName","reason","idCount","nextUnitID","nextStepID","cmd","batch","nextBarrierID","run","isEffect","toStack","samplerPriority","ref","before","graph","val","ownerUnit","_link","readSidRoot","flat","heap","v","getPriority","ret","r","l","queue","ix","first","last","size","bucket","t","Set","newForkPage","newPage","isGetState","isKernelCall","refsMap","sidValuesMap","sidIdMap","isFresh","needToAssign","err","compositeName","flattenConfig","part","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","ownerSet","history","effects","domains","unsubscribe","scopeFn","hookType","hooks","configA","configB","isDomain","unitId","serialize","thru","subscribe","observer","nativeTemplate","mapped","caller","storeRef","reader","needSpread","clone","stateNew","rawShape","storeStateRef","c","childRef","defaultShape","ok","sidechain","launchCase","scopeTargets","start","ctx","reject","parentFork","defers","launchUnits","launchParams","mapParams","attached","runnerSteps","runnerFnStep","computedParams","sourceData","isEffectHandler","setters","createDomain","Event","Effect","Store","Domain","factory","tag","lowerCaseTag","toLowerCase","acc","res","hook","domainOrConfig","optiionalConfig","forkInFlightCounter","fxID","resolve","__","storeStack","storeNode","resultScope","cloneOf","createScope","valuesSidMap","opts","observableItem","disposer","complete","METHOD","filterFn","filterIsUnit","guard","traverseTarget","normalizedValues","valuesSidList","getOwnPropertyNames","storeNodes","storeValues","savedForkPage","ignoredStores","ignore","onlyChanges","rawName","targets","match","knownCases","cases","matchIsUnit","matchIsFunction","matchIsShape","splitterSeq","caseNames","keys","String","lastValues","needBarrier","storeOrFn","updater","caseName","loc"],"mappings":"aAAO,SAASA,EACdC,EACAC,OAEK,IAAMC,KAAOF,EAChBC,EAAGD,EAAIE,GAAMA,GAwBV,SAASC,EAAQC,EAAWC,GACjCD,EAAKD,QAAQE,GC9BR,SAASC,EAAOC,EAAgBC,OAChCD,EAAW,MAAME,MAAMD,GCoBvB,SAASE,EAAWC,EAAWV,GACpCW,GAAc,CACZC,OAAQD,GACRE,MAAOH,EACPI,SAAUC,GAAQL,EAAM,aAAeM,KACvCC,QAASF,GAAQL,EAAM,YAAeC,IAAeA,GAAYM,oBAG1DjB,YAEPW,GAAcO,GAAUP,KCnBrB,SAASQ,sBA4BZ,SA3BFC,KAAAA,aAAO,SAGPR,WAGAS,MAAAA,eAFAC,MACAC,aAEAC,MAAAA,aAAQ,SACRC,KAAAA,aAAO,SACPC,OAAQC,aAAY,CAACC,KAAM,aAC3BC,IAAAA,SAkBMC,EAAUC,gBA3BhBC,QACAC,UA2BMC,EAAQH,GAAYJ,EAAUO,OAC9BC,EAASJ,GAAYJ,EAAUQ,QAC/BC,EAAa,GACnBlC,EAAQkB,GAAM,SAAAiB,UAAQA,GAAQC,EAAIF,EAAKC,UACjCE,EAAe,CACnBC,GAAIC,IACJL,IAAAA,EACAM,KAAMX,GAAYV,GAClBI,KAAAA,EACAD,MAAAA,EACAE,OAAQ,CACNE,KAAMD,EAAUC,MC/CG,YDgDnBM,MAAAA,EACAC,OAAAA,WAGJjC,EAAQgC,GAAO,SAAAS,UAAQL,EAAIM,GAAUD,GAAOJ,MAC5CrC,EAAQiC,GAAQ,SAAAU,UAASP,EAAIQ,GAASD,GAAQN,MAC9CrC,EAAQ4B,GAAS,SAAAG,UAAUK,EAAIL,EAAOS,KAAMH,MACxCV,GAAYlB,IACdoC,GAAIC,GAASrC,IAAc,CAAC4B,IAEvBA,EEuLF,SAASU,EAAOvC,EAAWwC,EAAeC,OAC3CC,EAAgBC,GAChBC,EAAiB,KACjBC,EAAoBC,MACpB9C,EAAKa,SACP2B,EAAUxC,EAAK+C,OACfN,EAASzC,EAAKgD,MACdN,EAAgB,SAAU1C,EAAOA,EAAKiD,KAAOP,EACzC1C,EAAI,QAAS4C,EAAiB5C,EAAI,OACtC6C,EAAoBK,GAAYlD,IAAS6C,EACzC7C,EAAOA,EAAKa,QAEVgC,GAAqBC,IAAYD,IAAsBC,KACzDA,GAAW,MAETK,MAAMC,QAAQpD,OACX,IAAIqD,EAAI,EAAGA,EAAIrD,EAAKsD,OAAQD,IAC/BE,GACE,OACAb,EACAc,GAASxD,EAAKqD,IACdT,EACAJ,EAAQa,GACRR,QAIJU,GACE,OACAb,EACAc,GAASxD,GACT4C,EACAJ,EACAK,OAGAJ,GAAWgB,QAIXC,EACAC,EACAjD,EACAP,EACA8C,EACAW,EAPEC,EAAmB,CAACJ,OAAAA,GAAQd,YAAAA,GAAa7B,MAAOgC,GAAUgB,QAAAA,IAChEL,GAAS,EAOG,yBACHM,EAAoB5D,EAApB4D,IAAKC,EAAe7D,EAAf6D,MAAO9C,EAAQf,EAARe,KACnBR,EAAOsD,EAAMtD,KACbiC,GAAcM,EAAOe,EAAMf,KAC3BH,GAAWI,GAAYc,GACnBf,EAAMW,EAAMX,EAAKW,IACZd,KAAUc,EAAMd,GAASc,SAE5BK,IAAehB,EACfiB,IAAgBpB,GAChBqB,EAAe,CACnBC,KAAM,EACNtD,MAAOJ,EAAKI,OAEd4C,EAAOC,EAAO,MACT,IAAIU,EAAQN,EAAKM,EAAQ3D,EAAKgB,IAAI4B,SAAWI,EAAMW,IAAS,KACzDC,EAAO5D,EAAKgB,IAAI2C,MAClBC,EAAKC,MAAO,OACgBD,EAAKC,MAA5BC,IAAAA,SAAUC,IAAAA,UACX3C,EAAK2C,EACPxB,EACKA,EAAKyB,WAAUD,EAClBA,EACF,KACAJ,IAAUN,GAAO7C,IAASsD,SACxBC,EACGE,GAASC,IAAI9C,KAChB6C,GAAS/C,IAAIE,GACb+C,GAASR,EAAOL,EAAOQ,EAAUC,IAGnCI,GAASR,EAAOL,EAAOQ,yBAI3BC,GAAaE,GAASG,OAAOhD,UAEvBwC,EAAKpD,UACN,UACG6D,EAAOT,EAAKS,KACd5E,gBAEI4E,EAAKzD,WACN0D,EAAO7E,EAAQmC,GAAS0B,aDnUpB,QCqUJ,IACH7D,EAAQ6D,EAAMe,EAAKzD,gBDzUZ,QC2UGnB,EAAQ4E,EAAKE,gBDrVhB,WCuVHrB,IAAQA,EAAImB,EAAKE,MAAMnD,OAErBmC,EAAY,KACRiB,EAAaC,GAAclC,EAAM8B,EAAKE,MAAMnD,IAClDkC,EAAMf,KAAOA,EAAOiC,EAChBA,EACFtB,EAAMsB,EAAWtB,IACRM,GACTkB,GAAetC,GAAWiC,EAAKE,MAAO,EAAO,EAAMF,EAAKM,UACxDzB,EAAMd,GAAUc,KAEhBA,OAAM0B,OAECpB,GAETkB,GAAetC,GAAWiC,EAAKE,MAAO,EAAO,EAAMF,EAAKM,UAQ5DlF,EAAQoF,GAAQ3B,GAAMA,EAAImB,EAAKE,MAAMnD,KAAoBiD,EAAKE,cAI1DF,EAAKnE,SACNoE,EAAOhB,EAAM7D,MAAQA,YDtWjB,QCwWJ,IACH6D,EAAMe,EAAKnE,IAAMT,YDtXV,QCyXPqF,GAAWvC,EAAMH,GAAUpC,EAAMqE,EAAKlE,QAAQ4E,QAAUtF,YAKzD,cACG4E,EAAOT,EAAKS,QACdA,EAAKrF,GAAI,CACXoE,GAAkC,UAAxBzD,GAAQK,EAAM,UAClBgF,EAAoBX,EAAKY,MAC3B,EAAWZ,EAAKrF,IAAI4C,GAAS0B,GAAQG,EAAMrD,MAAOkD,GAClD4B,GAAOzB,EAAOY,EAAKrF,GAAIsE,GACvBe,EAAKc,OAMPlC,GAAQ+B,EAER1B,EAAM7D,MAAQuF,EAEhB5B,GAAUD,EAAiBC,SAIjCJ,EAAOS,EAAMC,MAAQT,MAElBD,EAAM,KACHoC,EAAaxD,GAAS0B,GAC5BxE,EAAQkB,EAAKsB,MAAM,SAAA+D,GACjBxC,GACE,QACAN,EACA8C,EACA/B,EACA8B,EACA5C,GAAYc,WAGVlB,EAAWI,GAAYc,MACzBlB,EAAU,CACRzC,GAAQK,EAAM,kBAChB6C,GACE,QACAN,EACAH,EAASkD,QACThC,EACA8B,EACAhD,GAEAzC,GAAQK,EAAM,gBAChB6C,GACE,QACAN,EACAH,EAASmD,YACTjC,EACA8B,EACAhD,OAEEoD,EAAkBpD,EAASoD,gBAAgBxF,EAAKoB,IAClDoE,GACF1G,EAAQ0G,GAAiB,SAAAH,GACvBxC,GACE,QACAN,EACA8C,EACA/B,EACA8B,EACAhD,SAzJQ3C,EAAQgG,UAgK5B1C,GAASI,EAAiBJ,OAC1Bd,GAAckB,EAAiBlB,YAC/BG,GAAWI,GAAYW,IChclB,SAASuC,EAAeC,EAAeC,YAAAA,IAAAA,EAAiB,eACzDC,EAAOD,EAAS,IAChBE,EAAQ,GACRnD,EAAI,SACRjE,EAAMiH,GAAU,SAACrG,GAEXqD,EAAI,KACM,MAARrD,IACFuG,GAAQC,EACRD,GAAQE,EAAQzG,GAAQ0G,GAAc1G,GAAM2G,SAAW3G,EAAK4G,YAE9DvD,GAAK,EACLmD,EAAQ,SAGLD,EAAO,IAcT,SAASM,EAAWN,EAAcrG,OACnC4G,EACAH,EACEI,EAAYR,KACbrG,EAGE,KACC8G,EAAYN,GAAcxG,GACZ,IAAhBqG,EAAKjD,QACPwD,EAAOE,EAAUF,KACjBH,EAAWK,EAAUL,WAErBG,EAAOE,EAAUF,KAAKG,OAAO,CAACV,IAC9BI,EACgC,IAA9BK,EAAUL,SAASrD,OACfiD,EACKS,EAAUL,SAAW,IAAMJ,QAZxCO,EAAuB,IAAhBP,EAAKjD,OAAe,GAAK,CAACiD,GACjCI,EAAWJ,QAcN,CAACQ,UAAAA,EAAWJ,SAAAA,EAAUG,KAAAA,GChDxB,SAASI,EACdC,EACAC,OAEMC,EAAYD,EAAiBD,EAAOA,EAAK,UAC/CG,EAAaD,GAETA,EAAUE,MACZJ,EAAOE,EAAUE,KAEZ,CAACJ,EAJOE,EAAUG,ICXpB,SAASC,EACdnB,OAKMlG,EAAWE,QACbF,EAAU,SACNV,EAAUU,EAASsH,SAASpB,sBANjCa,mCAAAA,uBAOGzH,EAAI,OAAOA,gBAAGU,UAAa+G,KCqGnC,SAASQ,EAAW3H,EAAWI,EAAeoC,EAAc2E,OACpDS,EAAUjF,GACZM,EAAO,QACP7C,MACF6C,EAAON,GACAM,GAAQA,EAAK7C,WAAaA,GAC/B6C,EAAOzC,GAAUyC,GAGrB4E,GAAe5E,OACTpB,EAAS7B,EAAK8H,OAAOtF,EAAS2E,UACpCU,GAAeD,GACR/F,EAGF,SAASkG,EACdC,EACAC,OAEMC,EAAa,SAAbA,EAAc1F,GAClB2F,GACG9H,GAAQ6H,EAAO,WAChB,wBACA,0CAJqCf,mCAAAA,2BAMnCxE,GACKgF,EAAWO,EAAO9H,EAAUoC,EAAS2E,GAEvCe,EAAMJ,OAAOtF,EAAS2E,IAEzB/G,EAAWE,YACV8H,OAAOC,OAAOH,EAAO,CAC1BI,SAAU7H,EAAW,CACnBM,KAAMwH,GLjJS,QKiJOL,EAAOF,EAAcC,GAC3C9G,SAAU,IAEZ2G,gBAAO/E,UACLR,EAAO,CAAC1B,OAAQqH,EAAOnF,OAAAA,EAAQjC,MAAOgC,KAC/BC,GAETyF,MAAO,SAAC9I,UAAkC+I,GAAUP,EAAOxI,IAC3DgJ,IAAK,SAAChJ,UAAYiJ,GAAYT,EAAOU,EAAKlJ,EAAI,CAACmJ,EAAQ,CAACnJ,GAAIoJ,QAC5DjD,OAAQ,SAACnG,UACPiJ,GAAYT,ELhJI,SKgJWxI,EAAGA,GAAKA,EAAKA,EAAGA,GAAI,CAACmG,EAAO,CAACnG,GAAIoJ,QAC9DC,UAAW,SAACrJ,UACViJ,GAAYT,EAAO,YAAaxI,EAAI,CAClCmJ,EAAQ,CAACnJ,GAAIoJ,KACbE,GAAK,SAAA7I,UAAU8I,EAAO9I,KAAQ,MAElC+I,iBAAQxJ,OACAyJ,EAA2BpB,EAAY,YAASG,EAAMnB,UAAW,CACrE7G,OAAQM,GAAU0H,YAEpBT,EAAc,eAAgBjE,GAAS2F,IACvCC,GACED,EACAjB,EACA,CAACW,EAAQ,CAACnJ,GAAIoJ,MACd,UACApJ,GAEF2J,GAAgBnB,EAAOiB,GAChBA,KAKN,SAASG,EACdC,EACAC,OAEMC,EAAaC,GAAeH,GAC5BI,EAAUC,GAAiB,WACjCnC,EAAc,YAAagC,OACrBI,EAAeJ,EAAW3H,GAC1BmD,EAAa,CACjB6E,YAAa,IAAIC,IACjBJ,QAAAA,EACAJ,aAAAA,EACAS,SAAUP,EACVQ,wBAEMC,EADAC,EAAYV,KAEZ9G,GAAa,SACXM,EAAON,GACJM,IAASA,EAAKW,IAAIiG,IACvB5G,EAAOzC,GAAUyC,GAEfA,IAAMiH,EAAcjH,UAErBiH,GAAepH,KAClBsC,GAAetC,GAAU2G,EAAY,GACrCS,EAAcpH,IAEZoH,IAAaC,EAAYD,EAAYtG,IAAIiG,IACtCtE,GAAQ4E,IAEjBC,SAAU,SAACC,UACT9H,EAAO,CACL1B,OAAQoE,EACRlC,OAAQsH,EACRrH,MAAO,EACPlC,MAAOgC,MAEXwH,4CAASC,2BAAAA,yBACP/K,EAAQ+K,GAAO,SAAAvK,UAAQiF,EAAMuF,GAAGxK,GAAM,kBAAMiF,EAAMsE,mBAC3CtE,GAETuF,YAAGC,EAAc/K,UACfgL,EAAcD,EAAS,MAAO,kBAC9BtC,GACG9H,GAAQ4E,EAAO,WAChB,uBACA,eAEFzF,EAAQ2D,MAAMC,QAAQqH,GAAWA,EAAU,CAACA,IAAU,SAAAE,GACpD1F,EAAM2F,IAAID,GACVE,GAAe5F,GAAO6F,IACpBH,EACAI,GACEC,GAAYL,EAAS1F,EAAO,KAAMgG,GAAevL,QAIhDuF,GAET2F,aAAI5K,OACIkL,EAAsBL,GAAe5F,GAAOkG,IAAInL,UAClDkL,IACFA,IACAL,GAAe5F,GAAOH,OAAO9E,IAExBiF,GAETyD,aAAIhJ,EAAS0L,OACPC,EAUAC,EATAC,EAAS7L,KACX2L,EAAS3L,EACTA,EAAKA,EAAGA,IAEVyI,EACEc,EAAOmC,GACP,+BACA,oBAGII,EAAavG,EAAMgF,WACR3J,KAEfgL,EAAa,KACHrC,EAAOuC,KACjBF,EAAa5L,EAAG8L,EAAYJ,QAGxBK,EAAyBnC,EAAYgC,EAAY,CACrD/E,KAAStB,EAAM8B,sBACf2E,QAAS,EACTnE,IAAK8D,IAEDM,EAAWX,GAAY/F,EAAOwG,EAAY7C,EAAKgD,GAAelM,UACpEmM,GAASC,GAAcL,GAAa,CAClCvK,KAAM0H,EACNlJ,GAAAA,EACA4B,KAAMmI,IAERqC,GAAcL,GAAYM,OAAS,EACnCtE,EAAc,WAAYgC,EAAYkC,GAC/BF,GAETjD,eAAMwD,EAAgBtM,OACfA,IAAO+G,EAAQuF,GAAY,KACxBC,EAAexD,GAAUxD,EAAO+G,UACjCvE,EAAc,aAAcgC,EAAYuC,IAC3CA,EAAU/G,EAAMgF,YAEXgC,SAETtM,EAAOuM,EAAWxM,GAAK,wCAChBsM,EAAUxD,OAAM,SAAChG,UAAiB9C,EAAGuF,EAAMgF,WAAYzH,QAG5DzB,EAAOwH,GLtSM,QKsSUtD,EAAOuE,GAC9B2C,EAAelH,EAAMmH,cAAcD,aACzClH,EAAMqD,SAAW7H,EAAW,CAC1BK,MAAO,CAACuJ,MAAOZ,EAAY/J,GAAIyM,GAC/BzL,KAAM,CACJsI,GAAK,SAACqD,EAAKC,EAAGtI,UACRA,EAAMlD,QAAUkD,EAAMlD,MAAM8C,IAAI6F,EAAW3H,MAC7CkC,EAAMuI,EAAI,GAELF,KAETG,EAAK/C,GACLT,GAAK,SAACqD,EAAKC,SAAIG,IAAAA,EAAGF,IAAAA,SAAQtD,EAAOoD,KAASA,IAAQI,GAAKF,KAAI,GAC3DJ,GAAgBtG,EAAO,CAACnG,GAAIkM,KAC5Bc,EAAI,CAACpL,KAAM0D,EAAOnE,OAAQ4I,KAE5B9I,MAAOgJ,EACP5I,KAAAA,EACAI,SAAU,QAENwL,EAAqBtM,GAAQ4E,EAAO,cACtC0H,IACkC,WAAhCtM,GAAQ4E,EAAO,cACjB2H,GAAQ3H,EAAO,cAAe,GAChCwE,EAAWkD,IAAMA,GAEnBhN,EACEU,GAAQ4E,EAAO,aAAegE,EAAOM,GACrC,sDAEFlH,GAAI4C,EAAO,CAAC0E,IACL1E,ECpTF,SAAS4H,+BAAW1F,2BAAAA,sBACrB2F,EACAC,EACA1B,IACcnE,EAAoBC,GAA9BkE,WASJ2B,EACAC,EAwBAC,EAjCEC,GADJhG,QACsBA,EAAK7D,OAAS,MAClC4I,EAAWiB,IACbJ,EAAS5F,EAAKiG,MAAM,GAAI,GACxBN,EAAUK,GAEVJ,EAAS5F,EAKW,IAAlB4F,EAAOzJ,OAAc,KACjBjE,EAAM0N,EAAO,GAIdtG,EAASpH,KAcZ2N,EAAmB3N,EACnB4N,EAAa,OAIZA,IAIHD,EAAmBD,EAKfD,GAAS,CACXI,EAAgB,MACVxN,EAAKoN,EACXA,EAAU,SAACrN,UAAgBC,eAAMD,WAGrCE,EAAO4L,EAASyB,GAAmB,6BAC5BK,GACLlK,MAAMC,QAAQ4J,IACbE,EACDF,EACA3B,EACAyB,GC7EG,SAASQ,QAKRzL,EAAS,UAKfA,EAAO0L,IAAM,IAAIC,SAAQ,SAACC,EAAIC,GAC5B7L,EAAO4L,GAAKA,EACZ5L,EAAO6L,GAAKA,KAEd7L,EAAO0L,IAAII,OAAM,eACV9L,ECFF,SAAS+L,EACd5F,EACAC,OAEM4F,EAAgB9F,EACpBmE,EAAWlE,GAAgB,CAAC8E,QAAS9E,GAAgBA,EACrDC,GAEIvH,EAAO8C,GAASqK,GACtBjB,GAAQlM,EAAM,KAAOmN,EAASC,KRpBV,UQqBpBD,EAASE,IAAM,SAACrO,UACdC,EAAOuM,EAAWxM,GAAK,sCACvBsO,EAAOlN,MAAMgM,QAAUpN,EAChBmO,GAETA,EAASE,IAAIE,WAAa,kBAAMD,EAAOlN,MAAMgM,aACvCoB,EAAUL,EAASM,QAAUvE,GAAiB,WAC9CwE,EAAQP,EAASO,KAAQF,EAAenF,UAAU,CACtDsF,MAAO,OACP3O,kBACiB,WADb4O,OACqB,MAAO,CAACvL,SADrBA,OAC6BlB,SADrBA,WAIhBuC,EAAQyJ,EAASzJ,KAAQ8J,EAAenF,UAAU,CACtDsF,MAAO,OACP3O,kBACiB,WADb4O,OACqB,MAAO,CAACvL,SADrBA,OAC6BwL,QADrBA,UAIhBC,EAAYX,EAASW,SAAWJ,EAAK1F,IAAI,CAC7C2F,MAAO,WACP3O,GAAI,qBAAEmC,UAEF4M,EAAYZ,EAASY,SAAWrK,EAAKsE,IAAI,CAC7C2F,MAAO,WACP3O,GAAI,qBAAE6O,SAGFP,EAASvN,EAAW,CACxBK,MAAO,CACL4N,UAAWrO,GAAQK,EAAM,OACzBoM,QACEe,EAASzB,cAAcU,SACtB,kBAAMnN,EAAO,wBAA6BkO,EAASc,aAExDjO,KAAM,CACJsI,GACE,SAACqD,EAAKuC,EAAQ5K,OACNlD,EAAgD8N,EAClD9B,EAAUhM,EAAMgM,WAChB5J,GAAYc,GAAQ,KAChB6K,EAAW3L,GAAYc,GAAQ0D,SAAS5G,EAAM4N,WAChDG,IAAU/B,EAAU+B,UAE1BxC,EAAIS,QAAUA,EACPT,IAET,EACA,GAEFrD,GACE,WAA0CsD,EAAGtI,OAA3CjB,IAAAA,OAAQwK,IAAAA,IAAKT,IAAAA,YAAS3F,KAAAA,aAAO,CAACpE,KACxB+L,EAAYC,GAAUhM,EAAQwK,EAAK,EAAMW,EAAQlK,GACjDgL,EAAWD,GAAUhM,EAAQwK,EAAK,EAAOW,EAAQlK,KAClCiL,GAAMnC,EAASkC,EAAU7H,GAAnCtF,cAEL0J,EAAS1J,IAAWqK,EAAWrK,EAAOqN,MACxCrN,EAAOqN,KAAKJ,EAAWE,GAEvBF,EAAUjN,MAIhB,EACA,IAGJd,KAAM,CAACoO,GAAI,KAAMC,GAAI,YAEvB1O,EAAKI,MAAMkN,OAASA,EACpBpM,EACElB,EAAKgB,IACLsH,GACE,SAACjG,IAAkBiB,OAATgK,IAAAA,OACF3B,EAAM7L,GAAUwD,GAClB,CAACjB,OAAAA,EAAQwK,IAAK,CAACE,gBAAkBC,kBAEjC3K,SACJR,EAAO,CACL1B,OAAQmN,EACRjL,OAAQsJ,EACRrJ,MAAO,EACPlC,MAAOoC,GAAYc,KAEdqI,EAAItJ,SAEb,EACA,IAGJ8K,EAAS/F,OAAS,SAAC/E,OACXwK,EAAMD,IACN9K,EAAU,CAACO,OAAAA,EAAQwK,IAAAA,MACrBzK,GAAU,KACPgB,GAAS,KACNuL,EAAYvM,GAClByK,EAAIA,IACDY,SAAQ,WACPmB,GAAYD,MAEb1B,OAAM,eAEXpL,EAAO,CAAC1B,OAAQgN,EAAU9K,OAAQP,EAAS1B,MAAOgC,UAElDP,EAAOsL,EAAUrL,UAEZ+K,EAAIA,SAGPgC,EAAY1B,EAAS0B,SAAWjG,EAAY,EAAG,CAAC+E,MAAO,aAC1D7D,GAAGqD,GAAU,SAAA2B,UAAKA,EAAI,KACtBhF,GAAG0D,GAAQ,SAAAsB,UAAKA,EAAI,KACvB5C,GAAQsB,EAAQ,gBAAiB,OACjCtB,GAAQiB,EAAU,gBAAiB,OAC7B4B,EAAW5B,EAAS4B,QAAUF,EAAS7G,IAAI,CAE/ChJ,GAAI,SAAAgQ,UAAUA,EAAS,GACvBrB,MAAO,mBAGThM,GAAIwL,EAAU,CAACK,EAAQE,EAAMhK,EAAMoK,EAAUC,EAAUgB,EAASF,IACzD1B,EC1IF,SAAS8B,EACdC,EACAvE,OAEMxJ,EAASkG,EAAYsD,GAAUjF,EAAewJ,EAAQ,iBAC5DlF,EAAckF,EAAQ,QAAS,kBAC/BxG,GAAewG,EAAQ/N,EAAQ,GAAI,SAC5BA,ECUF,SAASgO,EAAqBxE,EAAa/E,OAC5CwJ,EAAwB,SAC5BtQ,EAAQuQ,IAAoB,SAAAC,GACtBA,KAAS3E,IACX1L,EAAwB,MAAjB0L,EAAO2E,GAAgBC,GAAkB3J,EAAQ0J,IACxDF,EAAwB,MAGrBA,EAkBF,SAASI,YACVrP,EACA0F,qBAFoBY,2BAAAA,sBAIpBwF,IADkCzF,EAAoBC,UAApD5F,OAAQ4O,OAAOzQ,OAAK0Q,OAEtBC,EAAU,EAGZpH,EAAOkH,IACP5E,EAAShK,IACTsO,EAAqBtO,EAAQ,YAE7B4O,EAAQ5O,EAAO4O,MACfzQ,EAAK6B,EAAO7B,GACZ2Q,GAAW9O,EAAO+O,OAElBzP,EAASU,EAAOV,OAChB0F,EAAOhF,EAAOgF,KACdoG,EAAMpL,EAAOoL,IACbpL,EAASA,EAAOA,cAECgP,GAAYhP,EAAQ4O,EAAO,UAA5C5O,OACE0H,EADMkH,UAGRA,EAAQ5O,GAEVmJ,EAAcyF,EAAO,SAAU,SAC1BC,GAAa7J,IAAMA,EAAOhF,EAAOwF,eAChCyJ,IAAa3P,MACdA,KACC4F,EAASlF,IAAWkF,EAAS0J,GAAQ,KACjCM,EAAe/Q,EACjBA,EAAG6F,GAAQuG,GAAcvK,IAAUgE,GAAQuG,GAAcqE,KACzD5K,GAAQuG,GAAcvK,IAC1BV,EAASyI,EAAYmH,EAAc,CAAClK,KAAAA,EAAMoG,IAAAA,EAAKnF,GAAI4I,SAEnDvP,EAASkH,EAAYxB,EAAM6J,GAC3B3I,EAAc,eAAgBjE,GAAS3C,OAKvC4F,EAASlF,GAAS,KACdmP,EAAY5E,GAAcvK,GAChCc,GAAId,EAAQ,CACV6H,GACE+G,EACAtP,EACA,CACE4G,EAAc,sBACd+E,EAAKkE,GAAYhR,EAAI2Q,GACrB3Q,GAAMmJ,EAAQ,CAACnJ,GAAIuL,KACnBxD,EAAc,qBAAsB+I,IV1FxB,SU6Fd9Q,KAIJ+H,EAAc,oBAAqBiJ,OAC9B,KACCC,EAAYjH,GAAe,GAC3BgH,EAAYhH,KACZkH,EAAalH,KACnBjC,EAAc,uBAAwBkJ,EAAWD,EAAWE,GAC5DnQ,EAAW,CACTP,OAAQqB,EACRb,KAAM,CACJgM,EAAI,CAACpL,KAAM0D,EAAOnE,OAAQ6P,IAC1BhE,EAAI,CAACpL,KV5GQ,QU4GK2D,MAAO,EAAMpE,OAAQ8P,KAEzC3P,OAAQ,CAACS,OAAQ,CAACF,EAAQV,EAAQsP,GAAQ3O,MAAOX,GACjDE,KAAM,CAACoO,GV9GS,UU+GhBhO,SAAU,IAEZkB,GAAId,EAAQ,CACV6H,GACE+G,EACAtP,EACA,CACE4G,EAAc,sBACdiF,EAAI,CAACpL,KAAM0D,EAAOnE,OAAQ+P,IAC1BpE,EAAKmE,EAAW,GAChB3H,GAAK,SAAA2H,UAAaA,IAAW,GAC7BnE,EAAKkE,EAAW,EAAML,GACtB7D,EAAKoE,GACLlR,GAAMmJ,EAAQ,CAACnJ,GAAIkM,KACnBnE,EAAc,qBAAsB+I,IV7HxB,SUgId9Q,YAKCmB,ECxIF,SAASgQ,EACdC,EACApR,OAEMD,EAAO,aACFsR,EAAMrQ,GACXsQ,EAASvR,EAAMiB,KACnBkB,EAAInC,EAAMiB,GXfO,UWgBbL,GAAQK,EAAM,OAAmBL,GAAQK,EAAM,QACjDhB,EAAGgB,EAAML,GAAQK,EAAM,QAEzBlB,EAAQkB,EAAKsB,KAAM+O,GACnBvR,EAAQ0C,GAAUxB,GAAOqQ,GACzBvR,EAAQ4C,GAAS1B,GAAOqQ,MACvBD,GAGE,SAASG,EACdC,EACAC,MAEIhO,MAAMC,QAAQ8N,KAASA,EAAS,IAAInH,IAAImH,IACxCA,aAAkBnH,IAAK,KACnBlI,EAAS,UACfrC,EAAQ0R,GAAQ,SAAC/Q,EAAOZ,GACtBI,EAAO8G,EAAQlH,GAAM,4BACjB4R,GAAYA,EAAW5R,EAAKY,GAChCR,EAAOJ,EAAIoN,IAAK,0BAChBhN,IAASJ,EAAIoN,OAAQ9K,GAAS,uBAC9BA,EAAOtC,EAAIoN,KAAQxM,KAEd0B,SAEFqP,wDVmDT,IW5FO,IAAME,EACQ,oBAAXC,QAA0BA,OAAOC,YAAe,eZM7C1I,EAAM,MACN5D,EAAQ,QaHRhF,EAAO,SAACX,UAClB6M,EAAW7M,IAAQkM,EAASlM,KAAS,SAAUA,GAE5CoH,EAAK,SAACvF,UAAe,SAAC7B,UAAaW,EAAKX,IAAQA,EAAIyO,OAAS5M,IAEtD+D,EAAQwB,EbVA,SaWRyB,EAAQzB,EbVA,SaWR8K,EAAS9K,EbVA,UaaT+K,EAAS/K,EbZA,UaaT3F,EAAQ2F,EbZA,6EJKRuK,EAAW,SAACvR,EAAakC,UAAclC,EAAKuR,SAASrP,IAErD8P,EAAa,SAAChS,EAAakC,OAChC+P,EAAMjS,EAAKkS,QAAQhQ,IACZ,IAAT+P,GACFjS,EAAKmS,OAAOF,EAAK,IAIR9P,EAAM,SAAInC,EAAWkC,UAAYlC,EAAKoS,KAAKlQ,ICd3CwG,EAAY,SACvBvI,EACAkS,EACAC,UAECnS,GACDoS,QAAQzD,MAASuD,yBAA8BC,eiBNpCxG,EAAW,SAACpL,SACN,iBAAVA,GAAgC,OAAVA,GAClB+L,EAAa,SAAC/L,SAAgC,mBAAVA,GAEpC8I,EAAS,SAAC9I,eAAyBmF,IAAVnF,GAEzBmH,EAAe,SAACnH,UAC3BR,EACE4L,EAASpL,IAAU+L,EAAW/L,GAC9B,uCAGE8R,EAAoB,SACxB9R,EACAmG,EACA4L,EACAC,UAEAxS,KAEM4L,EAASpL,KAAW+L,EAAW/L,MAC9B,WAAYA,MAAY,aAAcA,IAExCmG,cAAkB4L,2CAAkDC,IAG9DzH,EAAgB,SAC3BvK,EACAmG,EACA4L,GAEI/O,MAAMC,QAAQjD,GAChBX,EAAQW,GAAO,SAACwB,EAAM0B,UACpB4O,EAAkBtQ,EAAM2E,EAAWjD,cAAa6O,EAAa,OAG/DD,EAAkB9R,EAAOmG,EAAQ4L,EAAW,uBCxC1CE,EAAU,eACVtQ,EAAK,SACF,uBAAWA,IAGPuQ,EAAaD,IACbE,EAAaF,IACbrQ,EAAaqQ,ICMpBG,EAAM,SACVrR,EACA6D,EACAP,EACAgO,OAEM3Q,EAAc,CAClBC,GAAIwQ,IACJpR,KAAAA,EACA6D,KAAAA,UAEEP,IACF3C,EAAO0C,MAAQ,CAACC,SAAAA,GACZgO,IAAO3Q,EAAO0C,MAAME,YAAcgO,IAEjC5Q,GAGL4Q,EAAgB,EAEP/F,EAkDT,oBACFpL,KAEAT,IAAAA,WACAD,UAUI2R,EAAI,MAAO,CAACjR,gBhBjGG,UgBiGG2D,QAZtBA,MAY6BrE,cAVxBC,EhBvFc,QgBuFGmE,IAUWnE,OAAAA,KARjC2D,WADAgO,QAWW3J,EAAU,oBAIrBlD,SACAE,cAOa0M,EAAI,UAAW,CAAC7S,KAX7BA,GAWiCiG,gBAR1B,IAQgCE,kBAP9B,OAFTrB,WADAgO,QAYW3M,EAAS,mBAIhBgD,EAAQ,CAACnJ,KAHbA,GAGiBmG,OAAQ,KAEd6M,EAAM,mBAIb7J,EAAQ,CAACnJ,KAHbA,GAGiB8E,ShBzHG,YgB2HTwE,EAAO,SAClBtJ,EACAmG,EACA8M,UACG9J,EAAQ,CAACnJ,GAAAA,EAAIiG,KAAM,EAAME,OAAAA,EAAQrB,SAAUmO,GhB/H1B,YgB2ITnG,EAAO,SAClBvH,EACA2N,EACAC,UAEAnG,EAAI,CACFzH,MAAAA,EACArE,GAAIgS,EAAU5N,EhBvIG,IgBwIjBR,SAAUqO,GhBhJS,UgBiJnBL,MAAO,KAGElO,GAAO,CAACoI,IAAAA,EAAK7D,QAAAA,EAAShD,OAAAA,EAAQ6M,IAAAA,GCrJ9BhJ,GAAiB,SAACjE,SAA6B,CAC1D3D,GAAIwQ,IACJ7M,QAAAA,IAEWF,GAAU,qBAAEE,SAEZoG,GAAW,SAACiH,EAAe3D,GACjC2D,EAAIC,SAAQD,EAAIC,OAAS,IAC9BnR,EAAIkR,EAAIC,OAAS5D,ICVNvD,GAAgB,SAAC5H,cAAsCtE,IAAzBA,IAA4BsE,IAAjByI,IACzCxB,GAAgB,SAACjH,cAAsCtE,IAAzBA,MAAW+M,EAAoBzI,IAC7D8E,GAAY,SAAC9E,YAAoCtE,IAAvBA,IAA0BsE,ICDpDR,GAAW,SAACwP,UAAqBA,EAAM1K,UAAY0K,GACnD9Q,GAAY,SAACxB,UAAeA,EAAKM,OAAOS,QACxCW,GAAW,SAAC1B,UAAeA,EAAKM,OAAOQ,OACvCsK,GAAgB,SAAC7G,UAAyBA,EAAM+E,UAChD1H,GAAW,SAAC0B,UAAeA,EAAM7D,OACjC0K,GAAiB,SAAC5F,UAAeA,EAAM6E,aACvCtJ,GAAY,SAACR,UAAcA,EAAKE,QAChCgD,GAAc,SAAC+P,UAA2BA,EAAInS,OAC9CT,GAAU,SAACL,EAAWgQ,UAAkBxM,GAASxD,GAAMe,KAAKiP,IAC5DpD,GAAU,SAAC5M,EAAWgQ,EAAe7P,UAC/CqD,GAASxD,GAAMe,KAAKiP,GAAS7P,GCRnBkC,GAAM,SAAC6Q,EAAqB1R,OACjCW,EAAQqB,GAAS0P,GACvB1T,EAAQgC,GAAO,SAAA2R,OACPlR,EAAOuB,GAAS2P,GpBLJ,WoBMdhR,EAAMnB,OAAOE,OAAiBe,EAAKjB,OAAOE,KpBHzB,aoBIrBU,EAAIM,GAAUD,GAAOE,GACrBP,EAAIQ,GAASD,GAAQF,OtBAdhC,GAAkC,KAEhCK,GAAe,kBAC1BL,IAAeA,GAAYG,UAChBgT,GAAc,SAACzG,UACtBA,GAAO1M,IAAeA,GAAYM,UACpCoM,EAAS1M,GAAYM,YAAWoM,GAC3BA,GCVHtL,GAAc,SAClB5B,mBAAAA,IAAAA,EAAgD,KACpC0D,MAAMC,QAAQ3D,GAAQA,EAAO,CAACA,IAAO4T,OAAO3K,IAAIlF,KEiD1D8P,GAAyB,KAEvB3D,GAAQ,SAARA,EAASlD,EAAqBF,UAC7BE,EACAF,IAQFE,EAAE8G,EAAErS,OAASqL,EAAEgH,EAAErS,MAAQuL,EAAE8G,EAAEzR,GAAKyK,EAAEgH,EAAEzR,IAKvC0R,GAAY/G,EAAE8G,EAAErS,MAAQsS,GAAYjH,EAAEgH,EAAErS,SAExCuS,EAAMhH,EACNA,EAAIF,EACJA,EAAIkH,GAENA,EAAM9D,EAAMlD,EAAEiH,EAAGnH,GACjBE,EAAEiH,EAAIjH,EAAEkH,EACRlH,EAAEkH,EAAIF,EAEChH,GAvBQA,EADAF,MAGXkH,GAyBAG,GAAuB,GACzBC,GAAK,EACFA,GAAK,GAKVjS,EAAIgS,GAAO,CAACE,MAAO,KAAMC,KAAM,KAAMC,KAAM,IAC3CH,IAAM,EAGR,IAwGW/Q,GAxGLqD,GAAY,eACX,IAAI9C,EAAI,EAAGA,EAAI,EAAGA,IAAK,KACpB5D,EAAOmU,GAAMvQ,MACf5D,EAAKuU,KAAO,EAAG,IAKP,IAAN3Q,GAAiB,IAANA,EAAS,CACtB5D,EAAKuU,MAAQ,MACP7T,EAAQmT,GAAMC,SACpBD,GAAO3D,GAAM2D,GAAMK,EAAGL,GAAMI,GACrBvT,EAES,IAAdV,EAAKuU,OACPvU,EAAKsU,KAAO,UAERpS,EAAOlC,EAAKqU,aAClBrU,EAAKqU,MAAQnS,EAAM+R,EACnBjU,EAAKuU,MAAQ,EACNrS,EAAM4R,KAIbhQ,GAAoB,SACxBrC,EACA+B,EACAvC,EACAR,EACAC,EACAW,UAEA+D,GACE,EACA,CACE4H,EAAG,KACHF,EAAG,KACH7L,KAAAA,EACAR,OAAAA,EACAC,MAAAA,EACA8C,KAAAA,EACAnC,MAAAA,GAEFI,IAEE2D,GAAW,SACfd,EACAC,EACA9C,EACAY,YAAAA,IAAAA,EAAa,OAEP0C,EAAWgP,GAAYtS,GACvB+S,EAAsBL,GAAMpP,GAC5B7C,EAAkB,CACtB4R,EAAG,CACDxP,IAAAA,EACAC,MAAAA,EACA9C,KAAAA,EACAY,GAAAA,GAEF6R,EAAG,KACHD,EAAG,MAMY,IAAblP,GAA+B,IAAbA,EACpB8O,GAAO3D,GAAM2D,GAAM3R,IAEC,IAAhBsS,EAAOD,KACTC,EAAOH,MAAQnS,EAEfsS,EAAOF,KAAML,EAAI/R,EAEnBsS,EAAOF,KAAOpS,GAEhBsS,EAAOD,MAAQ,GAGXR,GAAc,SAACU,UACXA,OACD,eACI,MACJ,cACI,MACJ,cACI,MDnLU,iBCqLV,MDzLU,iBC2LV,MD9LS,gBCgMT,iBAEC,IAIRvP,GAAW,IAAIwP,IAEjB1Q,GAAS,EACFK,GAAU,EACVnB,GAA2B,KAEzB2M,GAAc,SAAC8E,GAC1BtR,GAAWsR,GAEAvM,GAAiB,SAACwM,GAC7B1R,GAAc0R,GAGVlP,GAAgB,SAAClC,EAAmBnB,MACpCmB,EAAM,MACDA,IAASA,EAAKW,IAAI9B,IACvBmB,EAAOzC,GAAUyC,MAEfA,EAAM,OAAOA,SAEZ,MAEIuC,GAAa,SACxBvC,EACAH,EACApC,EACAoS,EACAwB,OAEMpP,EAAaC,GAAclC,EAAM6P,EAAIhR,WACvCoD,EAAmBA,EAAWtB,IAAIkP,EAAIhR,IACtCgB,GACFsC,GAAetC,EAAWgQ,EAAKwB,GACxBxR,EAASc,IAAIkP,EAAIhR,KAEnBgR,GA+NI1N,GAAiB,SAAjBA,EACXtE,EAKA4P,EACA4D,EACAC,EACAlP,OAEMmP,EAAU1T,EAAM8C,IAChB+I,EAAM+D,EAAU/D,QAClB6H,EAAQ9D,EAAU5O,SAChBgR,EAAgB,CACpBhR,GAAI4O,EAAU5O,GACd2D,QAASiL,EAAUjL,YAGjBkH,GAAOA,KAAO7L,EAAM2T,gBAAkB9H,KAAO7L,EAAM4T,UACrD5B,EAAIrN,QAAU3E,EAAM2T,aAAa9H,WAE7B+D,EAAUqC,SAAW1N,EAAU,KAC7BsP,EAAU,EACRC,EAAeN,IAAe5D,EAAU3E,QAAUwI,EACxD/U,EAAQkR,EAAUqC,QAAQ,SAAAR,UAChBA,EAAIrR,WACL0H,MACGtH,EAAOiR,EAAIjR,QACbA,GAAQiR,EAAI7S,GAAI,CACd4B,GAAM8D,EAAetE,EAAOQ,EAAMgT,EAAYC,OAC5CpU,EAAQmB,GAAQkT,EAAQlT,EAAKQ,IAAI2D,QACnCmP,IACF9B,EAAIrN,QAAU8M,EAAI7S,GAAK6S,EAAI7S,GAAGS,GAASA,aAKxC,QACEwU,IACHA,EAAU,EAER7B,EAAIrN,QADFtC,MAAMC,QAAQ0P,EAAIrN,mBACFqN,EAAIrN,0BAEJqN,EAAIrN,UAG1BL,EAAetE,EAAOyR,EAAIjR,KAAMgT,EAAYC,GACxCK,IAEF9B,EAAIrN,QAAQ8M,EAAIvC,OAASwE,EADZA,EAAQjC,EAAIjR,KAAKQ,IACQA,IAAI2D,aAUlDkH,IAAK7L,EAAM4T,SAAS/H,GAAO+D,EAAU5O,IACzC0S,EAAQ9D,EAAU5O,IAAMgR,IAIpBlN,GAAS,SAACzB,EAAczE,EAAcsE,cAEjCtE,EAAG4C,GAAS0B,GAAQG,EAAMrD,MAAOkD,GACxC,MAAO6Q,GACP7C,QAAQzD,MAAMsG,GACd1Q,EAAMC,KAAO,IC3gBXsC,GAAgB,SAAC1G,UAA6BA,EAAK8U,eC6B5CC,GAAgB,SAAhBA,EAAiBC,EAAW3J,mBAAAA,IAAAA,EAAc,IACjDE,EAASyJ,KACXD,EAAcC,EAAKxN,GAAI6D,GACvBjM,EAAM4V,GAAM,SAAC7U,EAAO6P,GACb/G,EAAO9I,IAAoB,OAAV6P,GAA4B,QAAVA,IACtC3E,EAAO2E,GAAS7P,MAGpB4U,EAAcC,EAAKzN,IAAK8D,IAEnBA,GkBtCH4J,GAAiB,SAACC,EAAmBC,GACzC1D,EAAWyD,EAAYlT,KAAMmT,GAC7B1D,EAAWvP,GAAUgT,GAAcC,GACnC1D,EAAWrP,GAAS8S,GAAcC,IAE9BC,GAAsB,SAAtBA,EACJD,EACAE,EACAC,OAMIJ,EAJJC,EAAWnT,KAAKsB,OAAS,EACzB6R,EAAWzT,IAAI4B,OAAS,EAExB6R,EAAWrU,MAAQ,aAEfrB,EAAO2C,GAAS+S,GACZD,EAAczV,EAAK8V,OACzBN,GAAeC,EAAaC,IAE1BE,GACCC,GAA8C,WAA9BjV,GAAQ8U,EAAY,OrBpBlB,cqBqBnBD,EAAYlU,OAAOE,OAEnBkU,EACEF,EACAG,EAC+B,OAA/BhV,GAAQ6U,EAAa,OAAkBI,OAI7C7V,EAAOyC,GAAUiT,GACTD,EAAczV,EAAK8V,OACzBN,GAAeC,EAAaC,GACxBG,GrBjCiB,cqBiCDJ,EAAYlU,OAAOE,MACrCkU,EACEF,EACAG,EAC+B,OAA/BhV,GAAQ6U,EAAa,OAAkBI,IAKzCE,GAAW,SAAC9M,UAAaA,EAAI+M,SACtBC,GAAY,SACvBpN,SAEE+M,cAGE,MAHFA,KAKEC,EAAe,KAEfhN,EAASqN,UAAUrN,EAASqN,SAAS7Q,OAAOwD,GAC5C7B,EAAS6B,GACXkN,GAAS3K,GAAevC,SACnB,GAAI7B,EAAU6B,GAAW,CAC9BgN,EAAe,MAETM,EAAUtN,EAASsN,QACzBJ,GAASI,EAAQhG,QACjB4F,GAASI,EAAQC,SACjBL,GAASI,EAAQ7I,QACjByI,GAASI,EAAQE,SAEnBV,GAAoB5R,GAAS8E,KAAa+M,EAAMC,ICpErCvK,GAAqB,SAACrK,OAC3BmB,EAAS,kBAAM6T,GAAUhV,WAC/BmB,EAAOkU,YAAclU,EACdA,GCAIuH,GAAiB,SAC5BlJ,EACAS,EACAD,EACAyO,EACA6G,UAEAvV,EAAW,CACTC,KAAAA,EACAR,OAAAA,EACAS,MAAAA,EACAG,MAAO,CAACpB,GAAIsW,GACZjV,KAAM,CAACoO,GAAAA,GACPnO,OAAQ,CAACS,OAAQ,CAACvB,EAAQS,GAAQa,MAAOb,GACzCQ,SAAU,KCZDsH,GAAY,SACvBzI,EACA8M,UAEAnN,EAAOuM,EAAWY,GAAU,wCACrB/B,GACLtK,EAAW,CACTK,MAAO,CAACpB,GAAIoN,GACZpM,KAAM,CAACgS,EAAI,CAAChT,GAAIoJ,MAChB5I,OAAQF,EACRe,KAAM,CAACoO,GAAI,SACXnO,OAAQ,CAACS,OAAQzB,GACjBmB,SAAU,MnB0BHkI,GAAkB,SAC7B9H,EACAV,EACAoV,YAAAA,IAAAA,ELhDmB,SKkDfzV,GAAUe,IAASf,GAAUe,GAAQ2U,MAAMD,GAAUpV,IAG9C0H,GAAW,SAACuF,EAAW9N,EAAWmW,EAAcC,OACrDC,ELpDc,WKoDHvI,EACXhM,EAAKuQ,IACLhH,EAAS0J,GAAc,CAC3BvN,GAAI4O,EACJ7O,IAAwB,iBAAZ4O,EAAuB,CAAC5P,KAAM4P,GAAWA,MAEL9K,EAA3CnL,OAAAA,aAAS,SAAkCmL,EAA5BsB,IAAAA,aAAM,SAAsBtB,EAAhBgD,MAAAA,aAAQ,OACpC9H,EAAO8H,GAAgBhD,EAAO9E,OAAS8P,EAAW,GAAKvU,GACvDgT,EAAgBjO,EAAWN,EAAMrG,GACjCa,EAA4B,CAChCoO,GAAKnP,EAAK8N,KAAOA,EACjBvH,KAAOvG,EAAK+G,UAAYR,EACxBoG,IAAM3M,EAAK2M,IAAMyG,GAAYzG,GAC7B0B,MAAAA,EACAiI,OAAStW,EAAK8B,GAAKA,EACnByU,UAAWlL,EAAOkL,UAClB7K,QAASL,EAAOK,YAElB1L,EAAKE,OAASA,EACdF,EAAK8U,cAAgBA,EACrB9U,EAAKoM,cAAgBf,EACrBrL,EAAKwW,KAAO,SAAC9W,UACXyI,EAAU,EAAO,OAAQ,WAClBzI,EAAGM,IAEZA,EAAK2O,QAAU,kBAAMmG,EAAcnO,WAC9B0P,EAAU,CACbrW,EAAKyW,UAAY,SAACC,UAChBpP,EAAaoP,GACN1W,EAAKwI,MACV0D,EAAWwK,GACPA,EACA,SAACrK,UAAaqK,EAAS1U,MAAQ0U,EAAS1U,KAAKqK,MAGrDrM,EAAKoR,GAAoB,kBAAMpR,OACzBI,EAAWE,KACbF,IAAUW,EAAK4V,eAAiBvW,UAE/BW,GAEI6I,GAAmB,SAACyE,UAAkBtG,EAAY,CAACsG,MAAAA,KAE1D1F,GAAc,SAACT,EAAYiH,EAAYzP,EAASgB,OAChD2K,EACAE,EAAS7L,KACX2L,EAAS3L,EACTA,EAAKA,EAAGA,QAEJkX,EAAS7O,EAAY,CACzBxB,KAAS2B,EAAMnB,sBACf2E,QAAS,EACTnE,IAAK8D,WAEPjC,GAAelB,EAAO0O,EAAQlW,EAAMyO,EAAIzP,GACjCkX,GA0NH5L,GAAc,SAClB1J,EACA2D,EACAkK,EACA0H,EACAnX,OAEMoX,EAAWhL,GAAc7G,GACzB8R,EAASrK,EAAI,CACjBzH,MAAO6R,EACPlW,GLrUiB,IKsUjB4D,SAAU,SAER2K,IAAOvG,IAAKmO,EAAOhS,KAAKM,SAAW,OACjC3E,EAAO,CAACqW,EAAQlO,EAAQ,CAACnJ,GAAImX,YACnCpP,EACE,aACAqP,EACApW,EACA+F,EAASnF,IAASwK,GAAcxK,IAE3B8H,GAAe9H,EAAM2D,EAAOvE,EAAMyO,EAAIzP,IC5QzC2N,GAAmB,SACvBjK,EACA4T,EACA3X,EACAgM,EACA3L,OAEMuX,EAAQ7T,EAAU,SAAC3D,UAAcA,EAAK2N,SAAU,SAAC/N,2BAAkBA,IACnEkK,EAAoBnG,EAAU,GAAK,GAEnC8T,EAAWD,EAAM1N,GACjB4N,EAAWzN,GAAewN,GAC1BvC,EAAUjL,GAAe,GAC/ByN,EAASjW,KAAOkC,EAAU,OAAS,QACnC+T,EAASpL,OAAS,EAClBtE,EAAc,cAAe0P,EAAUxC,OACjC1P,EAAQqE,EAAY4N,EAAU,CAClC3Q,KAAMH,EAAe/G,GACrBqM,QAAS,EACTnE,IAAK8D,IAED+L,EAAgBtL,GAAc7G,GACpCmS,EAAcrL,OAAS,EACvBa,GAAQ3H,EAAO,YAAa,OACtBvE,EAAO,CACXsI,GAAK,SAACqD,EAAKC,EAAGtI,UACRA,EAAMlD,QAAUkD,EAAMlD,MAAM8C,IAAIuT,EAASrV,MAC3CkC,EAAMqT,EAAI,GAELhL,KAETG,EAAK2K,GACLzK,EAAI,CAACzH,MAAO0P,EAAS/T,GAAI,MACzBoI,GAAK,SAACqD,IAAYzI,OAANrE,IAAAA,OACNqE,EAAIyT,GAAKhL,IAAQzI,EAAI6I,EAAElN,UACrByX,GAAcpT,EAAI2I,IACpB3I,EAAI6I,EAAIwK,EAAMrT,EAAI6I,IAEpB7I,EAAI6I,EAAElN,GAAO8M,EACN,IAER,GACHK,EAAI,CAACpL,KN9GY,IM8GCT,OAAQsW,IAC1BzK,EAAI,CAACpL,KNlHY,QMkHC2D,MAAO,EAAOpE,OAAQ8T,IACxCjI,EAAI,CACFpL,KNpHe,QMqHf2D,MAAO,EACPpE,OAAQ8T,EACRnQ,SNxHiB,UMyHjBgO,MAAO,IAEThG,EAAK2K,EAAU,GACfzX,GAAMmJ,EAAQ,CAACnJ,GAAIoJ,aAErB1J,EAAMC,GAAK,SAACsB,EAAyBpB,OAC9BkH,EAAS9F,UACZhB,GACG8G,EAAQ9F,KAAWsI,EAAOtI,yCACWpB,QAExC2X,EAAS3X,GAAOgK,EAAahK,GAAOoB,GAGtC4I,EAAahK,GAAOoB,EAAM4I,aAC1B2N,EAAS3X,GAAOoB,EAAMsJ,eAChB0B,EAAWvC,GAAezI,EAAOsE,EAAOvE,EAAM,UAAWhB,GAC/DiM,EAAS7K,MAAMvB,IAAMA,MACf+X,EAAWxL,GAAcnL,GAC/BkL,GAASsL,EAAU,CAACjW,KAAM,QAAS8O,MAAOzQ,EAAK+B,KAAMgW,IACrD7P,EAAc,eAAgB6P,EAAU3L,MAG1C1G,EAAMsS,aAAelY,EACrBwM,GAASuL,EAAe,CACtBlW,KAAM0H,EACNtH,KAAM6V,EACNzX,GAAAA,IAEGY,OACH2E,EAAMsE,aAAe7J,EAChB0X,EAAc3R,QAAU/F,EAAGwX,GAC5B3N,GAECtE,GElBIgK,GAAQ,SACnBvP,EACAsP,EACA7H,aAGS,CAAC,EAAMzH,eAAMyH,IACpB,MAAO0N,UACP7F,EAAS6F,GACF,CAAC,EAAO,QAIN9F,GACX,SACEhM,EACAwK,EAIAiK,EACAtJ,EACAlK,UAEF,SAACe,UACCxC,EAAO,CACL1B,OAAQ,CAACqN,EAAQuJ,IACjB1U,OAAQ,CACNyU,EACI,CAAClJ,OAAQ,OAAQvL,OAAAA,EAAQlB,OAAQkD,GACjC,CAACuJ,OAAQ,OAAQvL,OAAAA,EAAQwL,MAAOxJ,GACpC,CAAC5E,MAAO4E,EAAMrF,GAAI8X,EAAKjK,EAAIE,GAAKF,EAAIG,KAEtC1K,MAAO,EACPC,KAAMe,EAAMf,KACZnC,MAAOoC,GAAYc,OAGZyT,GAAYhX,EAAW,CAClCC,KAAM,CAACgS,EAAI,CAAChT,GAAI,mBAAiBA,IAAfA,MAAIS,WACtBY,KAAM,CAACoO,GAAI,KAAMC,GAAI,eExKjBW,GAAqB,CAAC,SAAU,QAAS,UAEzCE,GAAoB,SAAC3J,EAAgB0J,UACzC1J,OAAc0J,wBAYHO,GAAc,SAAChP,EAAa4O,EAAY7J,UACnD3G,GACGsJ,EAAO1H,KAAY0H,EAAOkH,GAC3BF,GAAkB3J,EAAQ,2BAExB2C,EAAO1H,IACTmJ,EAAcyF,EAAO7J,EAAQ,SACzBnD,MAAMC,QAAQ+M,KAChBA,EAAQR,EAAMQ,IAEhB5O,EAAS4O,GACC1J,EAAQlF,KAClBA,EAASsL,EAAQtL,IAEZ,CAACA,EAAQ4O,IehCZuH,GAAa,SACjBC,EACA3H,EACAjL,EACAf,OAEMnD,EAAS8W,EAAa3H,GACxBnP,GACF0B,EAAO,CACL1B,OAAAA,EACAkC,OAAQI,MAAMC,QAAQvC,GAAUA,EAAO6H,KAAI,kBAAM3D,KAAQA,EACzD/B,MAAO,EACPgB,MAAAA,wBCrBC,SACL4T,SACC9W,IAAAA,MAAe+W,IAAR9U,WAEH0D,EAAQmR,GACX,OAAOpK,QAAQsK,OAAOhY,MAAM,sCACxBkD,EAAQsK,IAEdtK,EAAM+U,WAAajV,OACZkD,EAAWlF,EAAXkF,QACPpE,EAAIoE,EAAQlF,MAAMkX,OAAQhV,OAEpBiV,EAAc,CAACL,GACfM,EAAe,UACrBtW,EACEsW,EACAzR,EAAUmR,GACN,CACE7U,OAAQ8U,EACRtK,IAAK,CACHE,YAAGtN,GAED6C,EAAM7C,MAAQ,CAACmO,OAAQ,OAAQnO,MAAAA,IAEjCuN,YAAGvN,GAED6C,EAAM7C,MAAQ,CAACmO,OAAQ,OAAQnO,MAAAA,MAIrC0X,GAENjW,EAAIqW,EAAajS,GACjBpE,EAAIsW,EAAc,MAClB3V,EAAO,CACL1B,OAAQoX,EACRlV,OAAQmV,EACRpX,MAAAA,IAEKkC,EAAMuK,oBClCR,SAAgBlC,WAECnE,EAAoBmE,EAAQ,GAC7C9J,GADH8J,QACG9J,OAAQgQ,EAAqBlG,EAArBkG,OAAQ4G,EAAa9M,EAAb8M,UACfC,EAAWxK,EAAavC,QAC9BuB,GAAQwL,EAAU,WAAY,OAE1BC,EAoCEhO,EArCC2D,EAAUxK,GAAS4U,GAAUtX,MAA7BkN,OAEDsK,EAAetP,GACnB,SAACqD,EAAKC,EAAGtI,OAOHuU,EANGxV,EAAwBsJ,EAAxBtJ,OAAQwK,EAAgBlB,EAAhBkB,IAAKT,EAAWT,EAAXS,QACdoB,EAASkK,EAASjK,QAClBT,EAAKqB,GAAUhM,EAAQwK,EAAK,EAAOW,EAAQlK,GAC3CwU,EAAaxU,EAAMyI,EACnBgM,EAAkBhS,EAAUqG,GAC9B0K,EAAK,KAELW,EAAW,OACWlJ,GAAMkJ,EAAWzK,EAAI,CAAC3K,EAAQyV,IAApDhB,OAAIe,YAENA,EAAiBhX,GAAUkX,EAAkBD,EAAazV,KAExDyU,EAAI,KACFiB,SAWFpM,EAAIlF,KAAO,CAACqR,EAAYD,GACjB,EAXPhW,EAAO,CACL1B,OAAQiM,EACR/J,OAAQ,CACNA,OAAQwV,EACRhL,IAAK,CAACE,GAAIsB,GAAUhM,EAAQwK,EAAK,EAAMW,EAAQlK,GAAQ0J,GAAAA,IAEzDzK,KAAMe,EAAMf,KACZD,MAAO,OAQf,EACA,UAEEzB,GAEEkF,EAASlF,GAEXc,GADAgI,EAAQ9I,EACG,CAAC6W,KAEZ/N,EAAQwC,EAAQtL,GAChBc,GAAI+V,EAAU,CAAC/N,KAEjBgO,EAAc,CAAC7L,EAAKV,GAAczB,IAASiO,IAE3CD,EAAc,CAACC,MAEjBtK,EAAOtM,KAAIkQ,gBAAO,EAAG,UAAMyG,IAC3BD,EAASrK,IAAIwD,GACblI,GAAgBkI,EAAQ6G,E3BlEJ,U2BmEbA,4DC/DF,sCAAsBjR,2BAAAA,wBACQD,EAAoBC,UAAjDlC,OAAOyT,OAAUtI,OACjBvO,EAAqC,UAC3CzC,EAAMsZ,GAAS,SAAChZ,EAAIH,OACZ2I,EAASrG,EAAOtC,GAAOwI,EAAYxI,EAAK,CAC5CW,OAAQM,GAAUyE,GAClBoG,OAAQ+E,IAEVnL,EAAMuF,GAAGtC,EAAOxI,GAChB2J,GAAgBpE,EAAOiD,MAElBrG,wBCCF,SAAS8W,EAAa3Q,EAAmBC,OACxCvH,EAAOD,EAAW,CAACO,OAAQ,CAACE,K7BhBd,U6BgB6BC,SAAU,IAErDU,EAAc,CAClB+T,QAAS,GACTtN,SAAU5H,EACVwV,MAAO,IAGTxV,EAAKK,KAAOwH,G7BxBQ,S6BwBS1G,EAAQmG,EAAcC,GAEnD7I,EACE,CACEwZ,MAAO7Q,EACP8Q,OAAQjL,EACRkL,MAAOxP,EACPyP,OAAQJ,IAEV,SAACK,EAAcC,OACPC,EAAeD,EAAIE,cAEnBxO,EAAUf,QAAsBqP,GACtCpX,EAAOqU,MAAMgD,GAAgBvO,MAEvByO,EAAM,IAAIjF,IAChBtS,EAAO+T,QAAWsD,OAAmBE,EAErCzO,EAAQ7C,OAAS,SAAAuR,UACf9W,EAAOoI,EAAS0O,GACTA,GAETzX,EACE4B,GAASmH,GAASjJ,IAClBsH,GAAK,SAACqD,EAAKC,EAAGtI,UACZA,EAAMlD,MAAQ,KACPuL,MAGX1B,EAAQnC,OAAM,SAAAzD,GACZ1C,GAAIR,EAAQ,CAACkD,IACbqU,EAAIxX,IAAImD,GACHA,EAAK4Q,WAAU5Q,EAAK4Q,SAAWyD,GAC/B5Y,GAAUuE,KAAOA,EAAK7E,OAAS2B,MAEtCQ,GAAIR,EAAQ,CAAC8I,IAEb9I,aAAkBoX,GAAS,SAACK,UAC1B9Z,EAAQ4Z,EAAKE,GACN3O,EAAQnC,MAAM8Q,IAEvBzX,WAAgBoX,GAASpX,EAAOqX,GAAgB,SAC9ClR,EACAqD,UACGV,EAAQqO,EAAQhR,EAAc,CAAC9H,OAAQ2B,EAAQ2F,GAAI6D,aAItDnL,EAASM,GAAUqB,UACrB3B,GACFd,EAAMyC,EAAOqU,OAAO,SAAC5U,EAAgB/B,UACnC6J,GAAe9H,EAAMpB,EAAOgW,MAAM3W,OAG/BsC,qHvBsFF,kBACLsG,EAAU,EAAO,oBAAqB,WAC/B0E,wCwBnKF,SACL0M,EACAC,OAGIhI,EADAnG,EAAgDkO,EAEhD9S,EAAU8S,KACZ/H,EAAS+H,EACTlO,EAASmO,OAGL1Y,ECRD,SAAqBd,OACpByZ,EAAsBhZ,EAAW,CACrCK,MAAO,CACLkX,OAAQ,GACRzI,SAAU,EACVmK,KAAM,GAERhZ,KAAM,CACJsI,GAAK,SAACsD,EAAGxL,EAAOkD,GACTxD,GAAUwD,GAIyC,QAApD3D,GAAQG,GAAUwD,GAAOtD,KAAM,iBACjCI,EAAMyO,UAAY,GAElBzO,EAAMyO,UAAY,EAClBzO,EAAM4Y,MAAQ,GAPd5Y,EAAM4Y,MAAQ,KAUlB7Q,EAAQ,CAACrE,S/BxBQ,U+BwBWgO,MAAO,IACnCxJ,GACE,SAACsD,EAAGxL,OACKkX,EAAgBlX,EAAhBkX,OAAQ0B,EAAQ5Y,EAAR4Y,KACX5Y,EAAMyO,SAAW,GAAuB,IAAlByI,EAAO1U,QACjCkK,QAAQmM,UAAUzK,MAAK,WACjBpO,EAAM4Y,OAASA,GACnBla,EAAQwY,EAAOpG,OAAO,EAAGoG,EAAO1U,SAAS,SAACN,GACxCsM,GAAYtM,EAAM+U,YAClB/U,EAAMyK,GAAGzK,EAAM7C,eAIrB,EACA,MAKA8F,EAAcxF,EAAW,CAC7BC,KAAM,CACJsI,GAAK,SAAC7I,EAAOyZ,EAAI5V,OACT6V,EAAarZ,GAAUwD,MACzB6V,GAAcrZ,GAAUqZ,GAAa,KACjCC,EAAYD,EAAWnZ,SAE1BL,GAAQyZ,EAAW,cAC0B,YAA9CzZ,GAAQG,GAAUqZ,GAAYnZ,KAAM,MACpC,KACMoC,EAAWI,GAAYc,GACvBlC,EAAKgY,EAAUhZ,MAAMuJ,MAAMvI,GAC3B6K,EAAMtM,GAAQyZ,EAAW,OAC/BhX,EAAS4R,SAAS/H,GAAO7K,EACzBgB,EAAS2R,aAAa9H,GAAOxM,UAMjC4Z,EAAqB,CACzBC,QAASha,EACT4D,IAvBW,GAwBX6Q,aAAc,GACdC,SAAU,GACVzK,kBAAShF,MACH,YAAaA,SACRO,GAAW7C,GAAaoX,EAAa,KAAM9U,GAAOQ,YAErD/E,EAAO8C,GAASyB,UACfO,GAAW7C,GAAaoX,EAAarZ,EAAMA,EAAKI,MAAMuJ,MAAO,GACjE5E,SAELqI,K/B7EiB,Q+B8EjBxF,SAAU7H,EAAW,CACnBO,OAAQ,CACNE,K/BjFc,S+BkFdM,MAAO,CAACiY,EAAqBxT,IAE/BlF,KAAM,CAACf,KAAM,QACbc,MAAO,CAAC2Y,oBAAAA,KAEVvT,gBAAiB,GACjBwB,SAAU,GACV1B,QAASyT,EACTxT,YAAAA,UAEK8T,ED9EOE,CAAYzI,MAEtBnG,EAAQ,IACNA,EAAO6F,OAAQ,KACXgJ,EAAejJ,EAAgB5F,EAAO6F,QAAQ,SAAAlR,UAClDL,EAAO8G,EAASzG,GAAO,iDAEzBoI,OAAOC,OAAOvH,EAAM2T,aAAcyF,GAEhC7O,EAAO3D,WACT5G,EAAM4G,SAAWuJ,EAAgB5F,EAAO3D,UAAU,SAAA1H,UAChDL,EACE8G,EAAUzG,+DAMXc,mBPbc,SAACqZ,SAKOjT,EAAoBiT,EAAM,UAA/C7Y,IAAAA,KAAMV,IAAAA,GAAKyK,cACnBX,EAAcpJ,EAAM,UAAW,UAC/BoJ,EAAc9J,EAAI,UAAW,QACtBmK,GACLtK,EAAW,CACTP,OAAQoB,EACRX,MAAOC,EACPG,KAAM,CAACoO,GAAI,UAAW9D,OAAAA,GACtBrK,OAAQ,GACRG,SAAU,6BS7BT,SAA2BmQ,GAChChK,EAAagK,OACP8I,EACJhJ,KAAoBE,EAAaA,EAAWF,KAAsBE,EACpE3R,EAAOya,EAAe3D,UAAW,4CAC3BvO,EAAQH,IACRsS,EAAWtP,GAAmB7C,UACpCkS,EAAe3D,UAAU,CACvBzU,KAAMkG,EACNqG,MAAO8L,EACPC,SAAUD,IAELnS,iBCTF,mBACCqS,EAAS,2BADQpT,2BAAAA,wBAEYD,EAAoBC,UAAjD5F,OAAQ8J,OAAS+E,OAClB/E,IAEH9J,GADA8J,EAAS9J,GACOA,QAElBsO,EAAqBxE,EAAQkP,SAMzBlP,EAJMmP,IAAR3U,OACAyK,IAAAA,OACAH,IAAAA,UACA5J,KAAAA,aAAO6J,GAAYA,EAAS7J,KAAO6J,EAAS7J,KAAOgU,IAE/C1Z,EAASwK,EAAOxK,QAAUkH,EAAYxB,EAAM6J,GAC5CqK,EAAehU,EAAQ+T,KACVjK,GAAYhP,EAAQ4O,EAAOoK,UAA5ChZ,QAAQ4O,UAERzF,EAAcyF,EAAOoK,EAAQ,SAC7BhZ,EAAS2O,EAAO,CACd3O,OAAAA,EACA4O,MAAAA,EACAG,OAAAA,EACA5Q,GAAI+a,EAAe,KAAO,SAAClZ,EAAa4O,SAAgB,CAAC5O,OAAAA,EAAQ4O,MAAAA,OAGrEzF,EAAc7J,EAAQ0Z,EAAQ,UAC1BE,EACFvK,EAAO,CACL3O,OAAQiZ,EACRrK,MAAO5O,EACPV,OAAQJ,EAAW,CACjBC,KAAM,CAACsI,GAAK,qBAAE0R,QAAkB,GAAO1R,GAAK,qBAAEjE,SAC9CpE,MAAOE,EACPE,KAAM,CAACoO,GAAIoL,GACXvZ,OAAQ,CACNS,QAASF,EAAQiZ,EAAU3Z,UAAW,GAAGoG,OAAOkJ,GAAgB,KAChE3O,MAAOX,GAETM,SAAU,IAEZzB,GAAI,SAACgb,EAAY3V,SAAe,CAAC2V,MAAAA,EAAO3V,KAAAA,IACxCuL,OAAAA,EACA/J,KAAAA,KAGF5G,EAAOuM,EAAWsO,GAAW,uCAC7BpR,GACE7H,EACAV,EACAsP,EACI,CACEtK,EAAO,CAACnG,GAAI,qBAA2BA,IAARA,MAAjB6B,SAAQ4O,UACtBnH,GAAK,qBAAEzH,WAET,CAACsE,EAAO,CAACnG,GAAIoJ,MACjByR,EACAC,IAGG3Z,mBCpDF,SAAiB2Q,SAAyBN,IAAAA,OAC/CvR,EAAO4L,EAAS2F,GAAS,2CAKrBpO,EACA6X,EACA/F,EANEgG,EAAmB3J,EAAgBC,GACnC2J,EAAgBzS,OAAO0S,oBAAoBF,GAC3CG,EAAqB,GACrBC,EAAqB,GAIvBvU,EAAS+K,IAEXoD,EAAe,EACfjV,GAFAmD,EAAW0O,GAEKwI,QAAS,uCACzBW,EAAiBnX,GAASV,EAASkX,UAC1BvT,EAAU+K,GACnBmJ,EAAiBnX,GAASgO,GAE1B7R,EAAO,EAAO,uDAEhBkR,EAAe8J,GAAiB,SAACja,EAAMiM,GAEjCqE,EAAS6J,EAAelO,KAC1B/K,EAAImZ,EAAYra,GAChBkB,EAAIoZ,EAAaJ,EAAiBjO,QAGtCpK,EAAO,CACL1B,OAAQka,EACRhY,OAAQiY,EACRla,MAAOgC,IAEL8R,GACFxM,OAAOC,OAAOvF,EAAU2R,aAAcmG,kEC5CnC,SAAiBvb,EAAUkK,EAAmB8B,MAC/C5E,EAASpH,GAAM,OAAOA,KACtBoH,EAASpH,IAAQoH,EAAUpH,GAAM,KAC7BmS,EAAShR,GAAUnB,GACnBwC,EAASyH,EAAYC,EAAc,CACvCrJ,OAAQsR,EACRjL,KAAMlH,EAAI0H,UACVQ,IAAK8D,WAEPjC,GAAe3C,EAAUpH,GAAOA,EAAImP,SAAWnP,EAAKwC,GAChD2P,GAAQA,EAAO0E,MAAMjR,MAAMpD,GACxBA,MAEHA,EAA8BsB,MAAMC,QAAQ/D,GAAO,GAAK,UAC9DD,EACEC,GACA,SAACc,EAAOZ,UACLsC,EAAOtC,GAAOkH,EAAStG,GAASA,EAAQmJ,EAAYnJ,EAAO,CAACoG,KAAMhH,OAEhEsC,sCClBF,SAAmB7B,SAAYc,cAA0B,MAA1BA,MACpCnB,EACEmB,GAASgC,GACT,2DAEImY,EAAgBna,GAASgC,UACxB2D,EAAUzG,GACb,SAAC+C,OACOwK,EAAMD,WACZ/K,EAAO,CACL1B,OAAQb,EACR+C,OAAQ,CACNA,OAAAA,EACAwK,IAAAA,GAEFzM,MAAOma,IAEF1N,EAAIA,KAEb,SAACxK,UACCR,EAAO,CAAC1B,OAAQb,EAAM+C,OAAAA,EAAQjC,MAAOma,IAC9BlY,sBCnBR,SACLjC,EACAuK,YAAAA,IAAAA,EAA8D,QAExD6P,EAAgB7P,EAAO8P,OAAS9P,EAAO8P,OAAOzS,KAAI,qBAAEiE,OAAgB,GACpE9K,EAAS,UACfzC,EAAM0B,EAAM2T,cAAc,SAACtU,EAAOwM,OAC5BqE,EAASkK,EAAevO,QACtB7K,EAAKhB,EAAM4T,SAAS/H,GAGxB9K,EAAO8K,GADL7K,GAAMA,KAAMhB,EAAM8C,IACN9C,EAAM8C,IAAI9B,GAAI2D,QAEdtF,MAGd,gBAAiBkL,IAAWA,EAAO+P,cACrCzb,EAAOmB,EAAMkZ,QAAS,uCACtBnJ,EAAerN,GAAS1C,EAAMkZ,UAAU,SAACtZ,EAAMiM,GAEzCA,KAAO9K,GACRmP,EAASkK,EAAevO,IACxBtM,GAAQK,EAAM,cACgB,WAA/BL,GAAQK,EAAM,eAEdmB,EAAO8K,GAAO7L,EAAMmJ,SAASvJ,QAG5BmB,wBnCZF,SAA6BoD,EAAqBoW,GACvDpW,EAAM8B,UAAYsU,EAClBjT,OAAOC,OAAO3B,GAAczB,GAAQ4B,EAAWwU,EAAS7a,GAAUyE,oBuBK7D,mBACDqW,qBADmBnU,2BAAAA,wBAEWD,EAAoBC,UAAhD5F,OAAQga,OAAQnL,OAChBoL,GAAcD,EAChBC,IACFF,EAAU/Z,EAAOka,MACjBF,EAAQha,EAAOga,MACfha,EAASA,EAAOA,YAEZma,EAAcjV,EAAS8U,GACvBI,GAAmBlV,EAAQ8U,IAAUrP,EAAWqP,GAChDK,GAAgBF,IAAgBC,GAAmBpQ,EAASgQ,GAC7DD,IAAUA,EAAU,IACpBE,IACH7b,EAAOic,EAAc,6BACrBxc,EAAMmc,GAAO,SAACjP,EAAG/M,UAAS+b,EAAQ/b,GAAOwI,EAAYqI,MACrDkL,EAAQ1B,GAAK7R,EAAYqI,QAQvByL,EANEpa,EAAS,IAAI0S,IAChB,GAAkBlN,OAAO1F,EAAQ6G,OAAO8I,OAAOoK,KAE5CQ,EAAY1T,OAAO2T,KACvBL,GAAeC,EAAkBL,EAAUC,MAGzCG,GAAeC,EACbD,GAAaja,EAAOG,IAAI2Z,GAC5BM,EAAc,CACZH,GAAelP,EAAKV,GAAcyP,GAAQ,EAAO,GACjD1S,EAAQ,CACNlD,KAAM+V,EACN7V,OAAQ,EACRnG,YAAGqF,EAAM4S,EAAc3T,OACf7D,EAAQ6b,OAAON,EAAc1X,EAAMyI,EAAI8O,EAAMxW,IACnD2S,GACEC,EACA3G,EAAS8K,EAAW3b,GAASA,EAAQ,KACrC4E,EACAf,YAKH,GAAI4X,EAAc,KACjBK,EAAavS,GAAe,IAClCuS,EAAW/a,KAAO,YAEdgb,EADE3R,EAAQ,GAEdnL,EAAMmc,GAAO,SAACY,EAAgB5c,MACxBkH,EAAQ0V,GAAY,CACtBD,EAAc,EACdta,EAAI2I,EAAOhL,GACXkC,EAAOG,IAAIua,OACLC,EAAUhT,GACd+S,EACA,GACA,CAAC3P,EAAKyP,GAAajT,GAAK,SAACqD,EAAKC,cAAIG,EAAUlN,GAAO8M,UAEjD5F,EAAS0V,GAAY,CACvBF,EAAWxW,QAAQlG,GAAO4c,EAAUlS,eAC9B6M,EAAWhL,GAAcqQ,GAC/BtQ,GAASoQ,EAAY,CAAC3a,KAAMwV,EAAU9G,MAAOzQ,EAAK2B,KAAM,UACxDuG,EAAc,kBAAmBqP,EAAUsF,QAI7CF,GACFzU,EAAc,YAAawU,GAE7BJ,EAAc,CACZK,GAAgB1P,EAAKyP,EAAY,EAAO,GACxCpW,EAAO,CACLnG,YAAGqF,EAAM4S,EAAc3T,OAChB,IAAIX,EAAI,EAAGA,EAAIyY,EAAUxY,OAAQD,IAAK,KACnCgZ,EAAWP,EAAUzY,MACT2N,EAASzG,EAAO8R,GAC9BrY,EAAMyI,EAAE4P,GACRd,EAAMc,GAAUtX,eAElB2S,GAAWC,EAAc0E,EAAUtX,EAAMf,GAI7C0T,GAAWC,EAAc,KAAM5S,EAAMf,YAK3CrE,EAAO,EAAO,kDAEhBc,EAAW,CACTM,KAAM,CAACoO,GAAI,SACXjP,OAAQqB,EACRT,MAAOwa,EACP5a,KAAMmb,EACN7a,OAAQ,CAACS,OAAQ0B,MAAM7B,KAAKG,IAC5BN,SAAU,KAEPqa,EAAY,OAAOF,gE3B/FC,gBAEzB/U,IAAAA,KACA+V,IAAAA,IACAhW,IAAAA,OACA5G,IAAAA,UAWOK,EAHSU,EAAW,CACzBM,KAAM,CAACR,QAAS6S,KAblBzG,KAaoCpG,KAAAA,EAAM+V,IAAAA,EAAKhW,OAAAA,KAEpB5G"}